(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_haskell"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "cpp";
  "comment";
  "pragma";
]

let children_regexps : (string * Run.exp option) list = [
  "con_unit",
  Some (
    Seq [
      Token (Literal "(");
      Token (Literal ")");
    ];
  );
  "octal_literal", None;
  "namespace",
  Some (
    Alt [|
      Token (Literal "pattern");
      Token (Literal "type");
    |];
  );
  "do_keyword",
  Some (
    Alt [|
      Token (Literal "mdo");
      Token (Literal "do");
    |];
  );
  "binary_literal", None;
  "type_role",
  Some (
    Alt [|
      Token (Literal "representational");
      Token (Literal "nominal");
      Token (Literal "phantom");
      Token (Literal "_");
    |];
  );
  "unboxed_close", None;
  "hex_literal", None;
  "colon2",
  Some (
    Alt [|
      Token (Literal "\226\136\183");
      Token (Literal "::");
    |];
  );
  "char", None;
  "layout_semicolon", None;
  "varsym", None;
  "dot", None;
  "imm_tok_at", None;
  "arrow",
  Some (
    Alt [|
      Token (Literal "\226\134\146");
      Token (Literal "->");
    |];
  );
  "con_list",
  Some (
    Seq [
      Token (Literal "[");
      Token (Literal "]");
    ];
  );
  "consym", None;
  "larrow",
  Some (
    Alt [|
      Token (Literal "\226\134\144");
      Token (Literal "<-");
    |];
  );
  "unboxed_open",
  Some (
    Alt [|
      Token (Literal "(# ");
      Token (Literal "(#\n");
    |];
  );
  "where", None;
  "minus", None;
  "comma", None;
  "float", None;
  "type_star",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Literal "\226\152\133");
    |];
  );
  "deriving_strategy",
  Some (
    Alt [|
      Token (Literal "stock");
      Token (Literal "newtype");
      Token (Literal "anyclass");
    |];
  );
  "quasiquote_bar", None;
  "conid", None;
  "empty_file", None;
  "varid", None;
  "string", None;
  "carrow",
  Some (
    Alt [|
      Token (Literal "\226\135\146");
      Token (Literal "=>");
    |];
  );
  "safety",
  Some (
    Alt [|
      Token (Literal "unsafe");
      Token (Literal "safe");
      Token (Literal "interruptible");
    |];
  );
  "tok_barrbrack", None;
  "quasiquote_body", None;
  "quasiquote_start", None;
  "calling_convention",
  Some (
    Alt [|
      Token (Literal "ccall");
      Token (Literal "stdcall");
      Token (Literal "cplusplus");
      Token (Literal "jvm");
      Token (Literal "dotnet");
      Token (Literal "prim");
      Token (Literal "capi");
    |];
  );
  "layout_start", None;
  "splice_dollar", None;
  "strict", None;
  "pat_wildcard", None;
  "label", None;
  "layout_end", None;
  "integer_literal", None;
  "forall_kw",
  Some (
    Alt [|
      Token (Literal "forall");
      Token (Literal "\226\136\128");
    |];
  );
  "implicit_parid", None;
  "tyconsym", None;
  "operator", Some (Token (Name "varsym"););
  "tycon_arrow",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "arrow");
      Token (Literal ")");
    ];
  );
  "forall_dot",
  Some (
    Alt [|
      Token (Literal ".");
      Token (Name "arrow");
    |];
  );
  "constructor_operator", Some (Token (Name "consym"););
  "con_tuple",
  Some (
    Seq [
      Token (Literal "(");
      Repeat1 (
        Token (Name "comma");
      );
      Token (Literal ")");
    ];
  );
  "constructor", Some (Token (Name "conid"););
  "variable", Some (Token (Name "varid"););
  "type_variable", Some (Token (Name "varid"););
  "impent", Some (Token (Name "string"););
  "expent", Some (Token (Name "string"););
  "foreign_pre",
  Some (
    Seq [
      Token (Name "calling_convention");
      Opt (
        Token (Name "safety");
      );
    ];
  );
  "integer",
  Some (
    Alt [|
      Token (Name "binary_literal");
      Token (Name "integer_literal");
      Token (Name "octal_literal");
      Token (Name "hex_literal");
    |];
  );
  "type_operator",
  Some (
    Alt [|
      Token (Name "tyconsym");
      Token (Name "constructor_operator");
    |];
  );
  "modid", Some (Token (Name "constructor"););
  "ticked_tycon",
  Some (
    Seq [
      Token (Literal "`");
      Token (Name "constructor");
      Token (Literal "`");
    ];
  );
  "name",
  Some (
    Alt [|
      Alt [|
        Token (Name "variable");
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "operator");
            Token (Name "minus");
          |];
          Token (Literal ")");
        ];
      |];
      Alt [|
        Token (Name "constructor");
        Seq [
          Token (Literal "(");
          Token (Name "constructor_operator");
          Token (Literal ")");
        ];
      |];
    |];
  );
  "fun_name",
  Some (
    Alt [|
      Alt [|
        Token (Name "variable");
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "operator");
            Token (Name "minus");
          |];
          Token (Literal ")");
        ];
      |];
      Token (Name "implicit_parid");
    |];
  );
  "varop",
  Some (
    Alt [|
      Alt [|
        Token (Name "operator");
        Token (Name "minus");
      |];
      Seq [
        Token (Literal "`");
        Token (Name "variable");
        Token (Literal "`");
      ];
    |];
  );
  "import_name",
  Some (
    Alt [|
      Alt [|
        Token (Name "constructor");
        Seq [
          Token (Literal "(");
          Token (Name "constructor_operator");
          Token (Literal ")");
        ];
      |];
      Alt [|
        Token (Name "variable");
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "operator");
            Token (Name "minus");
          |];
          Token (Literal ")");
        ];
      |];
    |];
  );
  "pat_name",
  Some (
    Alt [|
      Token (Name "variable");
      Seq [
        Token (Literal "(");
        Alt [|
          Token (Name "operator");
          Token (Name "minus");
        |];
        Token (Literal ")");
      ];
    |];
  );
  "fundep",
  Some (
    Seq [
      Repeat1 (
        Token (Name "type_variable");
      );
      Token (Name "arrow");
      Repeat1 (
        Token (Name "type_variable");
      );
    ];
  );
  "tyfam_injectivity",
  Some (
    Seq [
      Token (Literal "|");
      Token (Name "type_variable");
      Token (Name "arrow");
      Repeat1 (
        Token (Name "type_variable");
      );
    ];
  );
  "literal",
  Some (
    Alt [|
      Alt [|
        Token (Name "string");
        Token (Name "char");
      |];
      Alt [|
        Token (Name "integer");
        Token (Name "float");
      |];
    |];
  );
  "qualified_type_operator",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "tyconsym");
    ];
  );
  "qualified_constructor",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "constructor");
    ];
  );
  "qualified_variable",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "variable");
    ];
  );
  "qualified_module",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "modid");
    ];
  );
  "qualified_operator",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Alt [|
        Token (Name "operator");
        Token (Name "minus");
      |];
    ];
  );
  "qualified_type",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "constructor");
    ];
  );
  "do_module",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "do_keyword");
    ];
  );
  "qualified_constructor_operator",
  Some (
    Seq [
      Repeat1 (
        Seq [
          Token (Name "modid");
          Token (Name "dot");
        ];
      );
      Token (Name "constructor_operator");
    ];
  );
  "export_names",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Alt [|
          Token (Literal "..");
          Opt (
            Seq [
              Token (Name "name");
              Repeat (
                Seq [
                  Token (Name "comma");
                  Token (Name "name");
                ];
              );
            ];
          );
        |];
      );
      Token (Literal ")");
    ];
  );
  "fixity",
  Some (
    Seq [
      Alt [|
        Token (Literal "infixl");
        Token (Literal "infixr");
        Token (Literal "infix");
      |];
      Opt (
        Token (Name "integer");
      );
      Alt [|
        Token (Name "varop");
        Alt [|
          Token (Name "constructor_operator");
          Seq [
            Token (Literal "`");
            Token (Name "constructor");
            Token (Literal "`");
          ];
        |];
      |];
      Repeat (
        Seq [
          Token (Name "comma");
          Alt [|
            Token (Name "varop");
            Alt [|
              Token (Name "constructor_operator");
              Seq [
                Token (Literal "`");
                Token (Name "constructor");
                Token (Literal "`");
              ];
            |];
          |];
        ];
      );
    ];
  );
  "import_con_names",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Alt [|
          Token (Literal "..");
          Seq [
            Token (Name "import_name");
            Repeat (
              Seq [
                Token (Name "comma");
                Token (Name "import_name");
              ];
            );
          ];
        |];
      );
      Token (Literal ")");
    ];
  );
  "fundeps",
  Some (
    Seq [
      Token (Literal "|");
      Token (Name "fundep");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "fundep");
        ];
      );
    ];
  );
  "type_literal",
  Some (
    Alt [|
      Token (Name "literal");
      Token (Name "con_unit");
      Token (Name "con_list");
      Token (Name "con_tuple");
    |];
  );
  "literal_",
  Some (
    Alt [|
      Token (Name "literal");
      Alt [|
        Token (Name "con_unit");
        Token (Name "con_list");
        Token (Name "con_tuple");
      |];
    |];
  );
  "quasiquote",
  Some (
    Seq [
      Alt [|
        Token (Literal "\226\159\166");
        Seq [
          Token (Name "quasiquote_start");
          Opt (
            Alt [|
              Token (Name "qualified_variable");
              Token (Name "variable");
            |];
          );
          Token (Name "quasiquote_bar");
        ];
      |];
      Opt (
        Token (Name "quasiquote_body");
      );
      Alt [|
        Token (Name "tok_barrbrack");
        Token (Literal "\226\159\167");
      |];
    ];
  );
  "qmodid",
  Some (
    Alt [|
      Token (Name "qualified_module");
      Token (Name "modid");
    |];
  );
  "qvarop_nominus",
  Some (
    Alt [|
      Alt [|
        Token (Name "qualified_operator");
        Token (Name "operator");
      |];
      Seq [
        Token (Literal "`");
        Alt [|
          Token (Name "qualified_variable");
          Token (Name "variable");
        |];
        Token (Literal "`");
      ];
    |];
  );
  "qvarop",
  Some (
    Alt [|
      Alt [|
        Token (Name "qualified_operator");
        Alt [|
          Token (Name "operator");
          Token (Name "minus");
        |];
      |];
      Seq [
        Token (Literal "`");
        Alt [|
          Token (Name "qualified_variable");
          Token (Name "variable");
        |];
        Token (Literal "`");
      ];
    |];
  );
  "ticked_qtycon",
  Some (
    Seq [
      Token (Literal "`");
      Alt [|
        Token (Name "qualified_type");
        Token (Name "constructor");
      |];
      Token (Literal "`");
    ];
  );
  "qualified_type_operator_",
  Some (
    Alt [|
      Token (Name "qualified_type_operator");
      Token (Name "qualified_constructor_operator");
    |];
  );
  "qcon",
  Some (
    Alt [|
      Alt [|
        Token (Name "qualified_constructor");
        Token (Name "constructor");
      |];
      Seq [
        Token (Literal "(");
        Alt [|
          Token (Name "qualified_constructor_operator");
          Token (Name "constructor_operator");
        |];
        Token (Literal ")");
      ];
    |];
  );
  "import_item",
  Some (
    Seq [
      Opt (
        Token (Name "namespace");
      );
      Alt [|
        Alt [|
          Token (Name "variable");
          Seq [
            Token (Literal "(");
            Alt [|
              Token (Name "operator");
              Token (Name "minus");
            |];
            Token (Literal ")");
          ];
        |];
        Seq [
          Alt [|
            Token (Name "constructor");
            Seq [
              Token (Literal "(");
              Token (Name "type_operator");
              Token (Literal ")");
            ];
          |];
          Opt (
            Token (Name "import_con_names");
          );
        ];
      |];
    ];
  );
  "qop",
  Some (
    Alt [|
      Token (Name "qvarop");
      Alt [|
        Alt [|
          Token (Name "qualified_constructor_operator");
          Token (Name "constructor_operator");
        |];
        Seq [
          Token (Literal "`");
          Alt [|
            Token (Name "qualified_constructor");
            Token (Name "constructor");
          |];
          Token (Literal "`");
        ];
      |];
    |];
  );
  "qtyconops",
  Some (
    Alt [|
      Token (Name "ticked_qtycon");
      Alt [|
        Token (Name "qualified_type_operator_");
        Token (Name "type_operator");
      |];
    |];
  );
  "decl_role",
  Some (
    Seq [
      Token (Literal "type");
      Token (Literal "role");
      Alt [|
        Alt [|
          Token (Name "qualified_type");
          Token (Name "constructor");
        |];
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "qualified_type_operator_");
            Token (Name "type_operator");
          |];
          Token (Literal ")");
        ];
      |];
      Repeat1 (
        Token (Name "type_role");
      );
    ];
  );
  "export",
  Some (
    Alt [|
      Alt [|
        Alt [|
          Token (Name "qualified_variable");
          Token (Name "variable");
        |];
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "qualified_operator");
            Alt [|
              Token (Name "operator");
              Token (Name "minus");
            |];
          |];
          Token (Literal ")");
        ];
      |];
      Seq [
        Opt (
          Token (Name "namespace");
        );
        Alt [|
          Alt [|
            Token (Name "qualified_type");
            Token (Name "constructor");
          |];
          Seq [
            Token (Literal "(");
            Alt [|
              Token (Name "qualified_type_operator_");
              Token (Name "type_operator");
            |];
            Token (Literal ")");
          ];
        |];
        Opt (
          Token (Name "export_names");
        );
      ];
      Seq [
        Token (Literal "module");
        Token (Name "qmodid");
      ];
    |];
  );
  "promoted_tycon",
  Some (
    Seq [
      Token (Literal "'");
      Alt [|
        Alt [|
          Token (Name "qualified_type");
          Token (Name "constructor");
        |];
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "qualified_type_operator_");
            Token (Name "type_operator");
          |];
          Token (Literal ")");
        ];
      |];
    ];
  );
  "exp_name",
  Some (
    Alt [|
      Alt [|
        Alt [|
          Token (Name "qualified_variable");
          Token (Name "variable");
        |];
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "qualified_operator");
            Alt [|
              Token (Name "operator");
              Token (Name "minus");
            |];
          |];
          Token (Literal ")");
        ];
      |];
      Token (Name "qcon");
      Token (Name "implicit_parid");
      Token (Name "label");
    |];
  );
  "pat_constructor", Some (Token (Name "qcon"););
  "import_list",
  Some (
    Seq [
      Opt (
        Token (Literal "hiding");
      );
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "import_item");
          Repeat (
            Seq [
              Token (Name "comma");
              Token (Name "import_item");
            ];
          );
          Opt (
            Token (Name "comma");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "promoted_tyconop",
  Some (
    Seq [
      Token (Literal "'");
      Token (Name "qtyconops");
    ];
  );
  "exports",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "export");
          Repeat (
            Seq [
              Token (Name "comma");
              Token (Name "export");
            ];
          );
        ];
      );
      Opt (
        Token (Name "comma");
      );
      Token (Literal ")");
    ];
  );
  "decl_import",
  Some (
    Seq [
      Token (Literal "import");
      Opt (
        Token (Literal "qualified");
      );
      Opt (
        Token (Name "string");
      );
      Token (Name "qmodid");
      Opt (
        Token (Literal "qualified");
      );
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "qmodid");
        ];
      );
      Opt (
        Token (Name "import_list");
      );
    ];
  );
  "qtyconop",
  Some (
    Alt [|
      Token (Name "promoted_tyconop");
      Token (Name "qtyconops");
    |];
  );
  "aexp",
  Some (
    Alt [|
      Token (Name "exp_name");
      Token (Name "exp_parens");
      Token (Name "exp_tuple_");
      Token (Name "exp_list");
      Token (Name "exp_th_quoted_name");
      Token (Name "exp_type_application");
      Token (Name "exp_lambda_case");
      Token (Name "exp_do");
      Token (Name "exp_record");
      Token (Name "exp_arithmetic_sequence");
      Token (Name "exp_list_comprehension");
      Token (Name "exp_section_left");
      Token (Name "exp_section_right");
      Token (Name "exp_unboxed_tuple");
      Token (Name "exp_unboxed_sum_");
      Token (Name "splice");
      Token (Name "quasiquote");
      Token (Name "literal_");
    |];
  );
  "alt",
  Some (
    Seq [
      Token (Name "pat");
      Token (Name "alt_variants");
      Opt (
        Seq [
          Token (Name "where");
          Opt (
            Token (Name "decls");
          );
        ];
      );
    ];
  );
  "alt_variants",
  Some (
    Alt [|
      Seq [
        Token (Name "arrow");
        Token (Name "exp");
      ];
      Repeat1 (
        Token (Name "gdpat");
      );
    |];
  );
  "alts",
  Some (
    Alt [|
      Seq [
        Token (Literal "{");
        Opt (
          Seq [
            Token (Name "alt");
            Repeat (
              Seq [
                Token (Literal ";");
                Token (Name "alt");
              ];
            );
          ];
        );
        Opt (
          Token (Literal ";");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Name "layout_start");
        Opt (
          Seq [
            Token (Name "alt");
            Repeat (
              Seq [
                Alt [|
                  Token (Literal ";");
                  Token (Name "layout_semicolon");
                |];
                Token (Name "alt");
              ];
            );
            Opt (
              Alt [|
                Token (Literal ";");
                Token (Name "layout_semicolon");
              |];
            );
          ];
        );
        Token (Name "layout_end");
      ];
    |];
  );
  "annotated_type_variable",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type_variable");
      Token (Name "type_annotation");
      Token (Literal ")");
    ];
  );
  "apat",
  Some (
    Alt [|
      Token (Name "pat_name");
      Token (Name "pat_as");
      Token (Name "pat_constructor");
      Token (Name "pat_record");
      Token (Name "literal_");
      Token (Name "pat_wildcard");
      Token (Name "pat_parens");
      Token (Name "pat_tuple");
      Token (Name "pat_unboxed_tuple");
      Token (Name "pat_unboxed_sum_");
      Token (Name "pat_list");
      Token (Name "pat_strict");
      Token (Name "pat_irrefutable");
      Token (Name "splice");
      Token (Name "quasiquote");
    |];
  );
  "atype",
  Some (
    Alt [|
      Token (Name "type_name");
      Token (Name "type_star");
      Token (Name "type_literal_");
      Token (Name "type_parens");
      Token (Name "type_unboxed_tuple");
      Token (Name "type_unboxed_sum");
      Token (Name "splice");
      Token (Name "quasiquote");
    |];
  );
  "bind_pattern",
  Some (
    Seq [
      Token (Name "typed_pat");
      Token (Name "larrow");
      Token (Name "exp");
    ];
  );
  "btype",
  Some (
    Alt [|
      Token (Name "atype");
      Token (Name "type_apply");
    |];
  );
  "constraint",
  Some (
    Alt [|
      Seq [
        Token (Name "type_name");
        Repeat (
          Token (Name "atype");
        );
      ];
      Token (Name "type_infix_");
    |];
  );
  "constraint_",
  Some (
    Alt [|
      Token (Name "quantified_constraint");
      Token (Name "constraint_context");
      Seq [
        Token (Literal "(");
        Token (Name "constraint_");
        Token (Literal ")");
      ];
      Token (Name "constraint");
    |];
  );
  "constraint_context",
  Some (
    Seq [
      Token (Name "context");
      Token (Name "constraint_");
    ];
  );
  "context",
  Some (
    Seq [
      Token (Name "context_constraints");
      Token (Name "carrow");
    ];
  );
  "context_constraints",
  Some (
    Seq [
      Alt [|
        Token (Name "constraint");
        Seq [
          Token (Literal "(");
          Opt (
            Seq [
              Alt [|
                Token (Name "constraint_");
                Token (Name "implicit_param");
              |];
              Repeat (
                Seq [
                  Token (Name "comma");
                  Alt [|
                    Token (Name "constraint_");
                    Token (Name "implicit_param");
                  |];
                ];
              );
            ];
          );
          Token (Literal ")");
        ];
      |];
    ];
  );
  "decl",
  Some (
    Alt [|
      Token (Name "gendecl");
      Token (Name "decl_fun");
    |];
  );
  "decl_fun",
  Some (
    Alt [|
      Token (Name "function");
      Token (Name "funpat");
    |];
  );
  "decls",
  Some (
    Alt [|
      Seq [
        Token (Literal "{");
        Opt (
          Seq [
            Token (Name "decl");
            Repeat (
              Seq [
                Token (Literal ";");
                Token (Name "decl");
              ];
            );
          ];
        );
        Opt (
          Token (Literal ";");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Name "layout_start");
        Opt (
          Seq [
            Token (Name "decl");
            Repeat (
              Seq [
                Alt [|
                  Token (Literal ";");
                  Token (Name "layout_semicolon");
                |];
                Token (Name "decl");
              ];
            );
            Opt (
              Alt [|
                Token (Literal ";");
                Token (Name "layout_semicolon");
              |];
            );
          ];
        );
        Token (Name "layout_end");
      ];
    |];
  );
  "exp",
  Some (
    Seq [
      Token (Name "exp_infix");
      Opt (
        Token (Name "type_annotation");
      );
    ];
  );
  "exp_apply",
  Some (
    Alt [|
      Token (Name "aexp");
      Seq [
        Token (Name "aexp");
        Token (Name "exp_apply");
      ];
      Seq [
        Token (Name "aexp");
        Token (Name "exp_lambda");
      ];
      Seq [
        Token (Name "aexp");
        Token (Name "exp_let_in");
      ];
      Seq [
        Token (Name "aexp");
        Token (Name "exp_cond");
      ];
      Seq [
        Token (Name "aexp");
        Token (Name "exp_case");
      ];
    |];
  );
  "exp_arithmetic_sequence",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "exp");
      Opt (
        Seq [
          Token (Name "comma");
          Token (Name "exp");
        ];
      );
      Token (Literal "..");
      Opt (
        Token (Name "exp");
      );
      Token (Literal "]");
    ];
  );
  "exp_case",
  Some (
    Seq [
      Token (Literal "case");
      Token (Name "exp");
      Token (Literal "of");
      Opt (
        Token (Name "alts");
      );
    ];
  );
  "exp_cond",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "exp");
      Opt (
        Token (Literal ";");
      );
      Token (Literal "then");
      Token (Name "exp");
      Opt (
        Token (Literal ";");
      );
      Token (Literal "else");
      Token (Name "exp");
    ];
  );
  "exp_do",
  Some (
    Seq [
      Alt [|
        Token (Name "do_module");
        Token (Name "do_keyword");
      |];
      Alt [|
        Seq [
          Token (Literal "{");
          Opt (
            Seq [
              Token (Name "stmt");
              Repeat (
                Seq [
                  Token (Literal ";");
                  Token (Name "stmt");
                ];
              );
            ];
          );
          Opt (
            Token (Literal ";");
          );
          Token (Literal "}");
        ];
        Seq [
          Token (Name "layout_start");
          Opt (
            Seq [
              Token (Name "stmt");
              Repeat (
                Seq [
                  Alt [|
                    Token (Literal ";");
                    Token (Name "layout_semicolon");
                  |];
                  Token (Name "stmt");
                ];
              );
              Opt (
                Alt [|
                  Token (Literal ";");
                  Token (Name "layout_semicolon");
                |];
              );
            ];
          );
          Token (Name "layout_end");
        ];
      |];
    ];
  );
  "exp_field",
  Some (
    Alt [|
      Token (Literal "..");
      Seq [
        Alt [|
          Alt [|
            Token (Name "qualified_variable");
            Token (Name "variable");
          |];
          Seq [
            Token (Literal "(");
            Alt [|
              Token (Name "qualified_operator");
              Alt [|
                Token (Name "operator");
                Token (Name "minus");
              |];
            |];
            Token (Literal ")");
          ];
        |];
        Opt (
          Seq [
            Token (Literal "=");
            Token (Name "exp");
          ];
        );
      ];
    |];
  );
  "exp_if_guard",
  Some (
    Seq [
      Token (Literal "if");
      Repeat1 (
        Token (Name "gdpat");
      );
    ];
  );
  "exp_in",
  Some (
    Seq [
      Token (Literal "in");
      Token (Name "exp");
    ];
  );
  "exp_infix",
  Some (
    Alt [|
      Token (Name "exp_infix_");
      Token (Name "lexp");
    |];
  );
  "exp_infix_",
  Some (
    Seq [
      Token (Name "exp_infix");
      Token (Name "qop");
      Token (Name "lexp");
    ];
  );
  "exp_lambda",
  Some (
    Seq [
      Token (Literal "\\");
      Repeat1 (
        Token (Name "apat");
      );
      Token (Name "arrow");
      Token (Name "exp");
    ];
  );
  "exp_lambda_case",
  Some (
    Seq [
      Token (Literal "\\");
      Token (Literal "case");
      Opt (
        Token (Name "alts");
      );
    ];
  );
  "exp_let",
  Some (
    Seq [
      Token (Literal "let");
      Opt (
        Token (Name "let_decls");
      );
    ];
  );
  "exp_let_in",
  Some (
    Seq [
      Token (Name "exp_let");
      Token (Name "exp_in");
    ];
  );
  "exp_list",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "exp");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "exp");
        ];
      );
      Token (Literal "]");
    ];
  );
  "exp_list_comprehension",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "exp");
      Token (Literal "|");
      Token (Name "qual");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "qual");
        ];
      );
      Token (Literal "]");
    ];
  );
  "exp_negation",
  Some (
    Seq [
      Token (Literal "-");
      Token (Name "aexp");
    ];
  );
  "exp_parens",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "exp");
      Token (Literal ")");
    ];
  );
  "exp_record",
  Some (
    Seq [
      Token (Name "aexp");
      Token (Literal "{");
      Token (Name "exp_field");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "exp_field");
        ];
      );
      Token (Literal "}");
    ];
  );
  "exp_section_left",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "exp_infix");
      Token (Name "qop");
      Token (Literal ")");
    ];
  );
  "exp_section_right",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "qvarop_nominus");
        Alt [|
          Alt [|
            Token (Name "qualified_constructor_operator");
            Token (Name "constructor_operator");
          |];
          Seq [
            Token (Literal "`");
            Alt [|
              Token (Name "qualified_constructor");
              Token (Name "constructor");
            |];
            Token (Literal "`");
          ];
        |];
      |];
      Token (Name "exp_infix");
      Token (Literal ")");
    ];
  );
  "exp_th_quoted_name",
  Some (
    Alt [|
      Seq [
        Token (Literal "'");
        Alt [|
          Alt [|
            Alt [|
              Token (Name "qualified_variable");
              Token (Name "variable");
            |];
            Seq [
              Token (Literal "(");
              Alt [|
                Token (Name "qualified_operator");
                Alt [|
                  Token (Name "operator");
                  Token (Name "minus");
                |];
              |];
              Token (Literal ")");
            ];
          |];
          Token (Name "qcon");
        |];
      ];
      Seq [
        Token (Literal "''");
        Token (Name "atype");
      ];
    |];
  );
  "exp_tuple",
  Some (
    Seq [
      Alt [|
        Seq [
          Repeat1 (
            Token (Name "comma");
          );
          Token (Name "exp");
        ];
        Seq [
          Token (Name "exp");
          Token (Name "comma");
          Opt (
            Token (Name "exp");
          );
        ];
      |];
      Repeat (
        Seq [
          Token (Name "comma");
          Opt (
            Token (Name "exp");
          );
        ];
      );
    ];
  );
  "exp_tuple_",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "exp_tuple");
      Token (Literal ")");
    ];
  );
  "exp_type_application",
  Some (
    Seq [
      Token (Literal "@");
      Token (Name "atype");
    ];
  );
  "exp_unboxed_sum",
  Some (
    Seq [
      Opt (
        Token (Name "exp");
      );
      Repeat1 (
        Seq [
          Token (Literal "|");
          Opt (
            Token (Name "exp");
          );
        ];
      );
    ];
  );
  "exp_unboxed_sum_",
  Some (
    Seq [
      Token (Name "unboxed_open");
      Token (Name "exp_unboxed_sum");
      Token (Name "unboxed_close");
    ];
  );
  "exp_unboxed_tuple",
  Some (
    Seq [
      Token (Name "unboxed_open");
      Opt (
        Seq [
          Opt (
            Token (Name "exp");
          );
          Repeat (
            Seq [
              Token (Name "comma");
              Opt (
                Token (Name "exp");
              );
            ];
          );
        ];
      );
      Token (Name "unboxed_close");
    ];
  );
  "fexp",
  Some (
    Alt [|
      Token (Name "aexp");
      Token (Name "exp_apply");
    |];
  );
  "forall",
  Some (
    Seq [
      Token (Name "forall_kw");
      Repeat1 (
        Alt [|
          Token (Name "annotated_type_variable");
          Token (Name "type_variable");
        |];
      );
    ];
  );
  "fun_arrow",
  Some (
    Seq [
      Opt (
        Token (Name "modifier");
      );
      Token (Name "arrow");
    ];
  );
  "fun_guards",
  Some (
    Repeat1 (
      Token (Name "guard_equation");
    );
  );
  "fun_patterns",
  Some (
    Repeat1 (
      Token (Name "apat");
    );
  );
  "function",
  Some (
    Seq [
      Token (Name "funlhs");
      Token (Name "funrhs");
    ];
  );
  "funlhs",
  Some (
    Alt [|
      Token (Name "funvar");
      Token (Name "funpat_infix");
    |];
  );
  "funpat",
  Some (
    Seq [
      Token (Name "typed_pat");
      Token (Name "funrhs");
    ];
  );
  "funpat_infix",
  Some (
    Seq [
      Token (Name "pat");
      Token (Name "varop");
      Token (Name "pat");
    ];
  );
  "funrhs",
  Some (
    Seq [
      Alt [|
        Seq [
          Token (Literal "=");
          Token (Name "exp");
        ];
        Token (Name "fun_guards");
      |];
      Opt (
        Seq [
          Token (Name "where");
          Opt (
            Token (Name "decls");
          );
        ];
      );
    ];
  );
  "funvar",
  Some (
    Seq [
      Token (Name "fun_name");
      Opt (
        Token (Name "fun_patterns");
      );
    ];
  );
  "gdpat",
  Some (
    Seq [
      Token (Name "guards");
      Token (Name "arrow");
      Token (Name "exp");
    ];
  );
  "gendecl",
  Some (
    Alt [|
      Token (Name "signature");
      Token (Name "fixity");
    |];
  );
  "guard",
  Some (
    Alt [|
      Token (Name "pattern_guard");
      Token (Name "let");
      Token (Name "exp_infix");
    |];
  );
  "guard_equation",
  Some (
    Seq [
      Token (Name "guards");
      Token (Literal "=");
      Token (Name "exp");
    ];
  );
  "guards",
  Some (
    Seq [
      Token (Literal "|");
      Token (Name "guard");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "guard");
        ];
      );
    ];
  );
  "implicit_param",
  Some (
    Seq [
      Token (Name "implicit_parid");
      Token (Name "type_annotation");
    ];
  );
  "let",
  Some (
    Seq [
      Token (Literal "let");
      Opt (
        Token (Name "decls");
      );
    ];
  );
  "let_decls",
  Some (
    Alt [|
      Seq [
        Token (Literal "{");
        Opt (
          Seq [
            Token (Name "decl");
            Repeat (
              Seq [
                Token (Literal ";");
                Token (Name "decl");
              ];
            );
          ];
        );
        Opt (
          Token (Literal ";");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Name "layout_start");
        Opt (
          Seq [
            Token (Name "decl");
            Repeat (
              Seq [
                Alt [|
                  Token (Literal ";");
                  Token (Name "layout_semicolon");
                |];
                Token (Name "decl");
              ];
            );
            Opt (
              Alt [|
                Token (Literal ";");
                Token (Name "layout_semicolon");
              |];
            );
          ];
        );
      ];
    |];
  );
  "lexp",
  Some (
    Alt [|
      Token (Name "exp_let_in");
      Token (Name "exp_cond");
      Token (Name "exp_if_guard");
      Token (Name "exp_case");
      Token (Name "exp_negation");
      Token (Name "fexp");
      Token (Name "exp_lambda");
    |];
  );
  "lpat",
  Some (
    Alt [|
      Token (Name "apat");
      Token (Name "pat_negation");
      Token (Name "pat_apply");
    |];
  );
  "modifier",
  Some (
    Seq [
      Token (Literal "%");
      Token (Name "atype");
    ];
  );
  "nested_pat",
  Some (
    Alt [|
      Token (Name "typed_pat");
      Token (Name "pat_view");
    |];
  );
  "pat",
  Some (
    Alt [|
      Token (Name "pat_infix");
      Token (Name "lpat");
    |];
  );
  "pat_apply",
  Some (
    Seq [
      Token (Name "pat_constructor");
      Repeat1 (
        Token (Name "apat");
      );
    ];
  );
  "pat_as",
  Some (
    Seq [
      Token (Name "variable");
      Token (Name "imm_tok_at");
      Token (Name "apat");
    ];
  );
  "pat_field",
  Some (
    Alt [|
      Token (Literal "..");
      Seq [
        Alt [|
          Alt [|
            Token (Name "qualified_variable");
            Token (Name "variable");
          |];
          Seq [
            Token (Literal "(");
            Alt [|
              Token (Name "qualified_operator");
              Alt [|
                Token (Name "operator");
                Token (Name "minus");
              |];
            |];
            Token (Literal ")");
          ];
        |];
        Opt (
          Seq [
            Token (Literal "=");
            Token (Name "nested_pat");
          ];
        );
      ];
    |];
  );
  "pat_fields",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "pat_field");
          Repeat (
            Seq [
              Token (Name "comma");
              Token (Name "pat_field");
            ];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "pat_infix",
  Some (
    Seq [
      Token (Name "lpat");
      Alt [|
        Alt [|
          Token (Name "qualified_constructor_operator");
          Token (Name "constructor_operator");
        |];
        Seq [
          Token (Literal "`");
          Alt [|
            Token (Name "qualified_constructor");
            Token (Name "constructor");
          |];
          Token (Literal "`");
        ];
      |];
      Token (Name "pat");
    ];
  );
  "pat_irrefutable",
  Some (
    Seq [
      Token (Literal "~");
      Token (Name "apat");
    ];
  );
  "pat_list",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "nested_pat");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "nested_pat");
        ];
      );
      Token (Literal "]");
    ];
  );
  "pat_negation",
  Some (
    Seq [
      Token (Literal "-");
      Token (Name "apat");
    ];
  );
  "pat_parens",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "nested_pat");
      Token (Literal ")");
    ];
  );
  "pat_record",
  Some (
    Seq [
      Token (Name "pat_constructor");
      Token (Name "pat_fields");
    ];
  );
  "pat_strict",
  Some (
    Seq [
      Token (Name "strict");
      Token (Name "apat");
    ];
  );
  "pat_tuple",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "nested_pat");
      Repeat1 (
        Seq [
          Token (Name "comma");
          Token (Name "nested_pat");
        ];
      );
      Token (Literal ")");
    ];
  );
  "pat_typed",
  Some (
    Seq [
      Token (Name "pat");
      Token (Name "type_annotation");
    ];
  );
  "pat_unboxed_sum",
  Some (
    Seq [
      Opt (
        Token (Name "nested_pat");
      );
      Repeat1 (
        Seq [
          Token (Literal "|");
          Opt (
            Token (Name "nested_pat");
          );
        ];
      );
    ];
  );
  "pat_unboxed_sum_",
  Some (
    Seq [
      Token (Name "unboxed_open");
      Token (Name "pat_unboxed_sum");
      Token (Name "unboxed_close");
    ];
  );
  "pat_unboxed_tuple",
  Some (
    Seq [
      Token (Name "unboxed_open");
      Opt (
        Seq [
          Token (Name "nested_pat");
          Repeat (
            Seq [
              Token (Name "comma");
              Token (Name "nested_pat");
            ];
          );
        ];
      );
      Token (Name "unboxed_close");
    ];
  );
  "pat_view",
  Some (
    Seq [
      Token (Name "exp");
      Token (Name "arrow");
      Token (Name "nested_pat");
    ];
  );
  "pattern_guard",
  Some (
    Seq [
      Token (Name "pat");
      Token (Name "larrow");
      Token (Name "exp_infix");
    ];
  );
  "qual",
  Some (
    Alt [|
      Token (Name "bind_pattern");
      Token (Name "let");
      Token (Name "transform");
      Token (Name "exp");
    |];
  );
  "quantified_constraint",
  Some (
    Seq [
      Token (Name "forall");
      Token (Name "forall_dot");
      Token (Name "constraint_");
    ];
  );
  "rec",
  Some (
    Seq [
      Token (Literal "rec");
      Alt [|
        Seq [
          Token (Literal "{");
          Opt (
            Seq [
              Token (Name "stmt");
              Repeat (
                Seq [
                  Token (Literal ";");
                  Token (Name "stmt");
                ];
              );
            ];
          );
          Opt (
            Token (Literal ";");
          );
          Token (Literal "}");
        ];
        Seq [
          Token (Name "layout_start");
          Opt (
            Seq [
              Token (Name "stmt");
              Repeat (
                Seq [
                  Alt [|
                    Token (Literal ";");
                    Token (Name "layout_semicolon");
                  |];
                  Token (Name "stmt");
                ];
              );
              Opt (
                Alt [|
                  Token (Literal ";");
                  Token (Name "layout_semicolon");
                |];
              );
            ];
          );
          Token (Name "layout_end");
        ];
      |];
    ];
  );
  "signature",
  Some (
    Seq [
      Alt [|
        Token (Name "variable");
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "operator");
            Token (Name "minus");
          |];
          Token (Literal ")");
        ];
      |];
      Repeat (
        Seq [
          Token (Name "comma");
          Alt [|
            Token (Name "variable");
            Seq [
              Token (Literal "(");
              Alt [|
                Token (Name "operator");
                Token (Name "minus");
              |];
              Token (Literal ")");
            ];
          |];
        ];
      );
      Token (Name "type_annotation");
    ];
  );
  "splice",
  Some (
    Seq [
      Token (Name "splice_dollar");
      Token (Name "splice_exp");
    ];
  );
  "splice_exp",
  Some (
    Alt [|
      Token (Name "exp_name");
      Token (Name "exp_parens");
    |];
  );
  "stmt",
  Some (
    Alt [|
      Token (Name "exp");
      Token (Name "bind_pattern");
      Token (Name "let");
      Token (Name "rec");
    |];
  );
  "transform",
  Some (
    Alt [|
      Seq [
        Token (Literal "then group by");
        Token (Name "exp");
        Token (Literal "using");
        Token (Name "exp");
      ];
      Seq [
        Token (Literal "then group using");
        Token (Name "exp");
      ];
      Seq [
        Token (Literal "then");
        Token (Name "exp");
      ];
    |];
  );
  "type",
  Some (
    Alt [|
      Token (Name "type_quantifiers");
      Token (Name "type_context");
      Token (Name "type_fun");
      Token (Name "type_infix");
    |];
  );
  "type_annotation",
  Some (
    Seq [
      Token (Name "colon2");
      Token (Name "type_or_implicit");
    ];
  );
  "type_apply",
  Some (
    Seq [
      Token (Name "atype");
      Repeat1 (
        Token (Name "atype");
      );
    ];
  );
  "type_context",
  Some (
    Seq [
      Token (Name "context");
      Token (Name "type");
    ];
  );
  "type_fun",
  Some (
    Seq [
      Token (Name "type_infix");
      Token (Name "fun_arrow");
      Token (Name "type");
    ];
  );
  "type_infix",
  Some (
    Alt [|
      Token (Name "type_infix_");
      Token (Name "btype");
    |];
  );
  "type_infix_",
  Some (
    Seq [
      Token (Name "btype");
      Token (Name "qtyconop");
      Token (Name "type_infix");
    ];
  );
  "type_list",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "type_or_implicit");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "type_or_implicit");
        ];
      );
      Token (Literal "]");
    ];
  );
  "type_literal_",
  Some (
    Alt [|
      Token (Name "type_promoted_literal");
      Token (Name "type_promotable_literal");
    |];
  );
  "type_name",
  Some (
    Alt [|
      Alt [|
        Token (Name "annotated_type_variable");
        Token (Name "type_variable");
      |];
      Alt [|
        Token (Name "promoted_tycon");
        Alt [|
          Alt [|
            Token (Name "qualified_type");
            Token (Name "constructor");
          |];
          Seq [
            Token (Literal "(");
            Alt [|
              Token (Name "qualified_type_operator_");
              Token (Name "type_operator");
            |];
            Token (Literal ")");
          ];
        |];
        Token (Name "tycon_arrow");
      |];
    |];
  );
  "type_or_implicit",
  Some (
    Alt [|
      Token (Name "implicit_param");
      Token (Name "type");
    |];
  );
  "type_parens",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type_or_implicit");
      Token (Literal ")");
    ];
  );
  "type_promotable_literal",
  Some (
    Alt [|
      Token (Name "type_literal");
      Token (Name "type_tuple_");
      Token (Name "type_list");
    |];
  );
  "type_promoted_literal",
  Some (
    Seq [
      Token (Literal "'");
      Token (Name "type_promotable_literal");
    ];
  );
  "type_quantifiers",
  Some (
    Seq [
      Token (Name "forall");
      Token (Name "forall_dot");
      Token (Name "type");
    ];
  );
  "type_sum",
  Some (
    Seq [
      Token (Name "type_or_implicit");
      Repeat1 (
        Seq [
          Token (Literal "|");
          Token (Name "type_or_implicit");
        ];
      );
    ];
  );
  "type_tuple",
  Some (
    Seq [
      Token (Name "type_or_implicit");
      Repeat1 (
        Seq [
          Token (Name "comma");
          Token (Name "type_or_implicit");
        ];
      );
    ];
  );
  "type_tuple_",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type_tuple");
      Token (Literal ")");
    ];
  );
  "type_unboxed_sum",
  Some (
    Seq [
      Token (Name "unboxed_open");
      Token (Name "type_sum");
      Token (Name "unboxed_close");
    ];
  );
  "type_unboxed_tuple",
  Some (
    Seq [
      Token (Name "unboxed_open");
      Opt (
        Seq [
          Token (Name "type_or_implicit");
          Repeat (
            Seq [
              Token (Name "comma");
              Token (Name "type_or_implicit");
            ];
          );
        ];
      );
      Token (Name "unboxed_close");
    ];
  );
  "typed_pat",
  Some (
    Alt [|
      Token (Name "pat");
      Token (Name "pat_typed");
    |];
  );
  "tyfam_result_type",
  Some (
    Seq [
      Token (Literal "=");
      Alt [|
        Token (Name "annotated_type_variable");
        Token (Name "type_variable");
      |];
    ];
  );
  "context_", Some (Token (Name "context"););
  "default_signature",
  Some (
    Seq [
      Token (Literal "default");
      Token (Name "signature");
    ];
  );
  "inst_tyinst",
  Some (
    Seq [
      Token (Literal "type");
      Opt (
        Token (Literal "instance");
      );
      Repeat (
        Token (Name "atype");
      );
      Token (Literal "=");
      Token (Name "type");
    ];
  );
  "strict_type",
  Some (
    Seq [
      Token (Name "strict");
      Token (Name "atype");
    ];
  );
  "pattern_type",
  Some (
    Seq [
      Alt [|
        Token (Name "constructor");
        Seq [
          Token (Literal "(");
          Token (Name "constructor_operator");
          Token (Literal ")");
        ];
      |];
      Token (Name "type_annotation");
    ];
  );
  "decl_default",
  Some (
    Seq [
      Token (Literal "default");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "type_infix");
          Repeat (
            Seq [
              Token (Name "comma");
              Token (Name "type_infix");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "decl_foreign_import",
  Some (
    Seq [
      Token (Literal "foreign");
      Token (Literal "import");
      Token (Name "foreign_pre");
      Opt (
        Token (Name "impent");
      );
      Token (Name "signature");
    ];
  );
  "pattern_equals",
  Some (
    Seq [
      Token (Name "pat");
      Token (Literal "=");
      Token (Name "pat");
    ];
  );
  "simpletype_infix",
  Some (
    Seq [
      Alt [|
        Token (Name "annotated_type_variable");
        Token (Name "type_variable");
      |];
      Alt [|
        Token (Name "ticked_tycon");
        Token (Name "type_operator");
      |];
      Alt [|
        Token (Name "annotated_type_variable");
        Token (Name "type_variable");
      |];
    ];
  );
  "via",
  Some (
    Seq [
      Token (Literal "via");
      Token (Name "type");
    ];
  );
  "pattern_decl",
  Some (
    Seq [
      Token (Name "pat");
      Token (Name "funrhs");
    ];
  );
  "top_splice", Some (Token (Name "exp_infix"););
  "decl_tyinst",
  Some (
    Seq [
      Token (Literal "type");
      Token (Literal "instance");
      Repeat (
        Token (Name "atype");
      );
      Token (Literal "=");
      Token (Name "type_or_implicit");
    ];
  );
  "forall_",
  Some (
    Seq [
      Token (Name "forall");
      Token (Name "forall_dot");
    ];
  );
  "decl_foreign_export",
  Some (
    Seq [
      Token (Literal "foreign");
      Token (Literal "export");
      Token (Name "foreign_pre");
      Opt (
        Token (Name "expent");
      );
      Token (Name "signature");
    ];
  );
  "tyfam_pat",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "qualified_type");
          Token (Name "constructor");
        |];
        Repeat (
          Token (Name "atype");
        );
      ];
      Seq [
        Token (Name "btype");
        Token (Name "qtyconop");
        Token (Name "btype");
      ];
    |];
  );
  "tyfam_inj",
  Some (
    Seq [
      Token (Name "tyfam_result_type");
      Opt (
        Token (Name "tyfam_injectivity");
      );
    ];
  );
  "field",
  Some (
    Seq [
      Token (Name "variable");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "variable");
        ];
      );
      Token (Name "colon2");
      Alt [|
        Token (Name "strict_type");
        Token (Name "type");
      |];
    ];
  );
  "data_constructor",
  Some (
    Seq [
      Token (Name "constructor");
      Repeat (
        Alt [|
          Token (Name "strict_type");
          Token (Name "atype");
        |];
      );
    ];
  );
  "gadt_fun",
  Some (
    Seq [
      Alt [|
        Token (Name "strict_type");
        Token (Name "type_infix");
      |];
      Token (Name "arrow");
      Token (Name "gadt_sig");
    ];
  );
  "gadt_sig",
  Some (
    Alt [|
      Token (Name "gadt_fun");
      Alt [|
        Token (Name "strict_type");
        Token (Name "type_infix");
      |];
    |];
  );
  "data_constructor_infix",
  Some (
    Seq [
      Alt [|
        Token (Name "strict_type");
        Token (Name "type_infix");
      |];
      Alt [|
        Token (Name "constructor_operator");
        Seq [
          Token (Literal "`");
          Token (Name "constructor");
          Token (Literal "`");
        ];
      |];
      Alt [|
        Token (Name "strict_type");
        Token (Name "type_infix");
      |];
    ];
  );
  "simpletype",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Token (Name "simpletype");
        Token (Literal ")");
      ];
      Token (Name "simpletype_infix");
      Seq [
        Alt [|
          Token (Name "constructor");
          Seq [
            Token (Literal "(");
            Token (Name "type_operator");
            Token (Literal ")");
          ];
        |];
        Repeat (
          Alt [|
            Token (Name "annotated_type_variable");
            Token (Name "type_variable");
          |];
        );
      ];
    |];
  );
  "deriving",
  Some (
    Seq [
      Token (Literal "deriving");
      Opt (
        Token (Name "deriving_strategy");
      );
      Alt [|
        Alt [|
          Token (Name "qualified_type");
          Token (Name "constructor");
        |];
        Seq [
          Token (Literal "(");
          Opt (
            Seq [
              Token (Name "constraint_");
              Repeat (
                Seq [
                  Token (Name "comma");
                  Token (Name "constraint_");
                ];
              );
            ];
          );
          Token (Literal ")");
        ];
      |];
      Opt (
        Token (Name "via");
      );
    ];
  );
  "pattern_arrow",
  Some (
    Seq [
      Token (Name "pat");
      Token (Name "larrow");
      Token (Name "pat");
      Opt (
        Seq [
          Token (Name "where");
          Alt [|
            Seq [
              Token (Literal "{");
              Opt (
                Seq [
                  Token (Name "pattern_decl");
                  Repeat (
                    Seq [
                      Token (Literal ";");
                      Token (Name "pattern_decl");
                    ];
                  );
                ];
              );
              Opt (
                Token (Literal ";");
              );
              Token (Literal "}");
            ];
            Seq [
              Token (Name "layout_start");
              Opt (
                Seq [
                  Token (Name "pattern_decl");
                  Repeat (
                    Seq [
                      Alt [|
                        Token (Literal ";");
                        Token (Name "layout_semicolon");
                      |];
                      Token (Name "pattern_decl");
                    ];
                  );
                  Opt (
                    Alt [|
                      Token (Literal ";");
                      Token (Name "layout_semicolon");
                    |];
                  );
                ];
              );
              Token (Name "layout_end");
            ];
          |];
        ];
      );
    ];
  );
  "datainst",
  Some (
    Seq [
      Opt (
        Token (Name "forall_");
      );
      Opt (
        Token (Name "context_");
      );
      Token (Name "type_infix");
      Opt (
        Token (Name "type_annotation");
      );
    ];
  );
  "instance",
  Some (
    Seq [
      Token (Literal "instance");
      Opt (
        Token (Name "forall_");
      );
      Opt (
        Token (Name "context_");
      );
      Token (Name "constraint");
    ];
  );
  "decl_foreign",
  Some (
    Alt [|
      Token (Name "decl_foreign_import");
      Token (Name "decl_foreign_export");
    |];
  );
  "tyfam_eq",
  Some (
    Seq [
      Token (Name "tyfam_pat");
      Token (Literal "=");
      Token (Name "type_or_implicit");
    ];
  );
  "record_fields",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "field");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "field");
        ];
      );
      Token (Literal "}");
    ];
  );
  "record_field",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "field");
      Token (Literal "}");
    ];
  );
  "context_newtype",
  Some (
    Alt [|
      Seq [
        Token (Name "context_");
        Token (Name "simpletype");
      ];
      Token (Name "simpletype");
    |];
  );
  "class_tyfam",
  Some (
    Seq [
      Token (Literal "type");
      Opt (
        Token (Literal "family");
      );
      Token (Name "simpletype");
      Opt (
        Token (Name "type_annotation");
      );
    ];
  );
  "tyfam_head", Some (Token (Name "simpletype"););
  "decl_datafam",
  Some (
    Seq [
      Token (Literal "data");
      Token (Literal "family");
      Token (Name "simpletype");
      Opt (
        Token (Name "type_annotation");
      );
    ];
  );
  "decl_type",
  Some (
    Seq [
      Token (Literal "type");
      Token (Name "simpletype");
      Alt [|
        Seq [
          Token (Literal "=");
          Token (Name "type_or_implicit");
        ];
        Token (Name "type_annotation");
      |];
    ];
  );
  "class_datafam",
  Some (
    Seq [
      Token (Literal "data");
      Opt (
        Token (Literal "family");
      );
      Token (Name "simpletype");
      Opt (
        Token (Name "type_annotation");
      );
    ];
  );
  "decl_pattern",
  Some (
    Seq [
      Token (Literal "pattern");
      Alt [|
        Token (Name "pattern_type");
        Token (Name "pattern_equals");
        Token (Name "pattern_arrow");
      |];
    ];
  );
  "decl_deriving",
  Some (
    Seq [
      Token (Literal "deriving");
      Opt (
        Alt [|
          Token (Name "deriving_strategy");
          Token (Name "via");
        |];
      );
      Token (Name "instance");
    ];
  );
  "data_constructor_record",
  Some (
    Seq [
      Token (Name "constructor");
      Token (Name "record_fields");
    ];
  );
  "gadt_constr_type",
  Some (
    Seq [
      Token (Name "colon2");
      Opt (
        Token (Name "forall_");
      );
      Opt (
        Token (Name "context_");
      );
      Alt [|
        Token (Name "gadt_sig");
        Seq [
          Token (Name "record_fields");
          Token (Name "arrow");
          Token (Name "gadt_sig");
        ];
      |];
    ];
  );
  "newtype_constructor",
  Some (
    Seq [
      Token (Name "constructor");
      Alt [|
        Token (Name "atype");
        Token (Name "record_field");
      |];
    ];
  );
  "decl_tyfam",
  Some (
    Seq [
      Token (Literal "type");
      Token (Literal "family");
      Token (Name "tyfam_head");
      Opt (
        Alt [|
          Token (Name "type_annotation");
          Token (Name "tyfam_inj");
        |];
      );
      Opt (
        Seq [
          Token (Name "where");
          Opt (
            Alt [|
              Seq [
                Token (Literal "{");
                Opt (
                  Seq [
                    Token (Name "tyfam_eq");
                    Repeat (
                      Seq [
                        Token (Literal ";");
                        Token (Name "tyfam_eq");
                      ];
                    );
                  ];
                );
                Opt (
                  Token (Literal ";");
                );
                Token (Literal "}");
              ];
              Seq [
                Token (Name "layout_start");
                Opt (
                  Seq [
                    Token (Name "tyfam_eq");
                    Repeat (
                      Seq [
                        Alt [|
                          Token (Literal ";");
                          Token (Name "layout_semicolon");
                        |];
                        Token (Name "tyfam_eq");
                      ];
                    );
                    Opt (
                      Alt [|
                        Token (Literal ";");
                        Token (Name "layout_semicolon");
                      |];
                    );
                  ];
                );
                Token (Name "layout_end");
              ];
            |];
          );
        ];
      );
    ];
  );
  "cdecl",
  Some (
    Alt [|
      Token (Name "gendecl");
      Token (Name "default_signature");
      Token (Name "function");
      Token (Name "class_tyfam");
      Token (Name "inst_tyinst");
      Token (Name "class_datafam");
    |];
  );
  "constructors",
  Some (
    Seq [
      Opt (
        Token (Name "forall_");
      );
      Opt (
        Token (Name "context_");
      );
      Alt [|
        Token (Name "data_constructor");
        Token (Name "data_constructor_infix");
        Token (Name "data_constructor_record");
      |];
      Repeat (
        Seq [
          Token (Literal "|");
          Opt (
            Token (Name "forall_");
          );
          Opt (
            Token (Name "context_");
          );
          Alt [|
            Token (Name "data_constructor");
            Token (Name "data_constructor_infix");
            Token (Name "data_constructor_record");
          |];
        ];
      );
    ];
  );
  "gadt_constructor",
  Some (
    Seq [
      Alt [|
        Token (Name "constructor");
        Seq [
          Token (Literal "(");
          Token (Name "constructor_operator");
          Token (Literal ")");
        ];
      |];
      Token (Name "gadt_constr_type");
    ];
  );
  "newtype",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "newtype_constructor");
      Repeat (
        Token (Name "deriving");
      );
    ];
  );
  "class_body",
  Some (
    Seq [
      Token (Name "where");
      Opt (
        Alt [|
          Seq [
            Token (Literal "{");
            Opt (
              Seq [
                Token (Name "cdecl");
                Repeat (
                  Seq [
                    Token (Literal ";");
                    Token (Name "cdecl");
                  ];
                );
              ];
            );
            Opt (
              Token (Literal ";");
            );
            Token (Literal "}");
          ];
          Seq [
            Token (Name "layout_start");
            Opt (
              Seq [
                Token (Name "cdecl");
                Repeat (
                  Seq [
                    Alt [|
                      Token (Literal ";");
                      Token (Name "layout_semicolon");
                    |];
                    Token (Name "cdecl");
                  ];
                );
                Opt (
                  Alt [|
                    Token (Literal ";");
                    Token (Name "layout_semicolon");
                  |];
                );
              ];
            );
            Token (Name "layout_end");
          ];
        |];
      );
    ];
  );
  "adt_rhs",
  Some (
    Seq [
      Token (Literal "=");
      Token (Name "constructors");
      Repeat (
        Token (Name "deriving");
      );
    ];
  );
  "gadt_rhs",
  Some (
    Seq [
      Token (Name "where");
      Opt (
        Alt [|
          Seq [
            Token (Literal "{");
            Opt (
              Seq [
                Alt [|
                  Token (Name "gadt_constructor");
                  Token (Name "deriving");
                |];
                Repeat (
                  Seq [
                    Token (Literal ";");
                    Alt [|
                      Token (Name "gadt_constructor");
                      Token (Name "deriving");
                    |];
                  ];
                );
              ];
            );
            Opt (
              Token (Literal ";");
            );
            Token (Literal "}");
          ];
          Seq [
            Token (Name "layout_start");
            Opt (
              Seq [
                Alt [|
                  Token (Name "gadt_constructor");
                  Token (Name "deriving");
                |];
                Repeat (
                  Seq [
                    Alt [|
                      Token (Literal ";");
                      Token (Name "layout_semicolon");
                    |];
                    Alt [|
                      Token (Name "gadt_constructor");
                      Token (Name "deriving");
                    |];
                  ];
                );
                Opt (
                  Alt [|
                    Token (Literal ";");
                    Token (Name "layout_semicolon");
                  |];
                );
              ];
            );
            Token (Name "layout_end");
          ];
        |];
      );
    ];
  );
  "decl_class",
  Some (
    Seq [
      Token (Literal "class");
      Opt (
        Token (Name "context_");
      );
      Token (Name "constraint");
      Opt (
        Token (Name "fundeps");
      );
      Opt (
        Token (Name "class_body");
      );
    ];
  );
  "adt",
  Some (
    Seq [
      Alt [|
        Token (Name "adt_rhs");
        Token (Name "gadt_rhs");
      |];
    ];
  );
  "decl_newtype",
  Some (
    Seq [
      Token (Literal "newtype");
      Token (Name "context_newtype");
      Alt [|
        Token (Name "newtype");
        Seq [
          Opt (
            Token (Name "type_annotation");
          );
          Token (Name "gadt_rhs");
        ];
      |];
    ];
  );
  "decl_adt",
  Some (
    Seq [
      Token (Literal "data");
      Opt (
        Token (Name "context_");
      );
      Token (Name "simpletype");
      Opt (
        Token (Name "type_annotation");
      );
      Opt (
        Alt [|
          Token (Name "adt");
          Repeat (
            Token (Name "deriving");
          );
        |];
      );
    ];
  );
  "inst_datainst",
  Some (
    Alt [|
      Seq [
        Token (Literal "data");
        Opt (
          Token (Literal "instance");
        );
        Token (Name "datainst");
        Opt (
          Token (Name "adt");
        );
      ];
      Seq [
        Token (Literal "newtype");
        Opt (
          Token (Literal "instance");
        );
        Token (Name "datainst");
        Token (Name "newtype");
      ];
    |];
  );
  "decl_datainst",
  Some (
    Alt [|
      Seq [
        Token (Literal "data");
        Token (Literal "instance");
        Token (Name "datainst");
        Opt (
          Token (Name "adt");
        );
      ];
      Seq [
        Token (Literal "newtype");
        Token (Literal "instance");
        Token (Name "datainst");
        Token (Name "newtype");
      ];
    |];
  );
  "idecl",
  Some (
    Alt [|
      Token (Name "function");
      Token (Name "signature");
      Token (Name "inst_datainst");
      Token (Name "inst_tyinst");
    |];
  );
  "decl_instance",
  Some (
    Seq [
      Token (Name "instance");
      Opt (
        Seq [
          Token (Name "where");
          Opt (
            Alt [|
              Seq [
                Token (Literal "{");
                Opt (
                  Seq [
                    Token (Name "idecl");
                    Repeat (
                      Seq [
                        Token (Literal ";");
                        Token (Name "idecl");
                      ];
                    );
                  ];
                );
                Opt (
                  Token (Literal ";");
                );
                Token (Literal "}");
              ];
              Seq [
                Token (Name "layout_start");
                Opt (
                  Seq [
                    Token (Name "idecl");
                    Repeat (
                      Seq [
                        Alt [|
                          Token (Literal ";");
                          Token (Name "layout_semicolon");
                        |];
                        Token (Name "idecl");
                      ];
                    );
                    Opt (
                      Alt [|
                        Token (Literal ";");
                        Token (Name "layout_semicolon");
                      |];
                    );
                  ];
                );
                Token (Name "layout_end");
              ];
            |];
          );
        ];
      );
    ];
  );
  "topdecl",
  Some (
    Alt [|
      Token (Name "decl_type");
      Token (Name "decl_tyfam");
      Token (Name "decl_tyinst");
      Token (Name "decl_role");
      Token (Name "decl_adt");
      Token (Name "decl_newtype");
      Token (Name "decl_datafam");
      Token (Name "decl_datainst");
      Token (Name "decl_import");
      Token (Name "decl_class");
      Token (Name "decl_instance");
      Token (Name "decl_default");
      Token (Name "decl_foreign");
      Token (Name "decl_deriving");
      Token (Name "decl");
      Token (Name "decl_pattern");
      Token (Name "top_splice");
    |];
  );
  "module",
  Some (
    Seq [
      Token (Literal "module");
      Token (Name "qmodid");
      Opt (
        Token (Name "exports");
      );
      Token (Name "where");
      Opt (
        Alt [|
          Seq [
            Token (Literal "{");
            Opt (
              Seq [
                Token (Name "topdecl");
                Repeat (
                  Seq [
                    Token (Literal ";");
                    Token (Name "topdecl");
                  ];
                );
              ];
            );
            Opt (
              Token (Literal ";");
            );
            Token (Literal "}");
          ];
          Seq [
            Token (Name "layout_start");
            Opt (
              Seq [
                Token (Name "topdecl");
                Repeat (
                  Seq [
                    Alt [|
                      Token (Literal ";");
                      Token (Name "layout_semicolon");
                    |];
                    Token (Name "topdecl");
                  ];
                );
                Opt (
                  Alt [|
                    Token (Literal ";");
                    Token (Name "layout_semicolon");
                  |];
                );
              ];
            );
            Token (Name "layout_end");
          ];
        |];
      );
    ];
  );
  "haskell",
  Some (
    Alt [|
      Token (Name "empty_file");
      Token (Name "module");
      Seq [
        Token (Name "topdecl");
        Repeat (
          Seq [
            Alt [|
              Token (Literal ";");
              Token (Name "layout_semicolon");
            |];
            Token (Name "topdecl");
          ];
        );
        Opt (
          Alt [|
            Token (Literal ";");
            Token (Name "layout_semicolon");
          |];
        );
      ];
    |];
  );
]

let trans_con_unit ((kind, body) : mt) : CST.con_unit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_octal_literal ((kind, body) : mt) : CST.octal_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_namespace ((kind, body) : mt) : CST.namespace =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_do_keyword ((kind, body) : mt) : CST.do_keyword =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Mdo (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Do (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_binary_literal ((kind, body) : mt) : CST.binary_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_type_role ((kind, body) : mt) : CST.type_role =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Repr (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Nomi (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Phan (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `X__ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_unboxed_close ((kind, body) : mt) : CST.unboxed_close =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_hex_literal ((kind, body) : mt) : CST.hex_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_colon2 ((kind, body) : mt) : CST.colon2 =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `UNKUNKUNK (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `COLONCOLON (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_char ((kind, body) : mt) : CST.char =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_layout_semicolon ((kind, body) : mt) : CST.layout_semicolon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_varsym ((kind, body) : mt) : CST.varsym =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_dot ((kind, body) : mt) : CST.dot =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_imm_tok_at ((kind, body) : mt) : CST.imm_tok_at =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_arrow ((kind, body) : mt) : CST.arrow =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `UNKUNKUNK (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASHGT (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_con_list ((kind, body) : mt) : CST.con_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_consym ((kind, body) : mt) : CST.consym =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_larrow ((kind, body) : mt) : CST.larrow =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `UNKUNKUNK (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LTDASH (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_unboxed_open ((kind, body) : mt) : CST.unboxed_open =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPARHASHSPACE (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LPARHASHLF (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_where ((kind, body) : mt) : CST.where =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_minus ((kind, body) : mt) : CST.minus =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_comma ((kind, body) : mt) : CST.comma =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_float_ ((kind, body) : mt) : CST.float_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_type_star ((kind, body) : mt) : CST.type_star =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `UNKUNKUNK (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_deriving_strategy ((kind, body) : mt) : CST.deriving_strategy =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Stock (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Newt (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Anyc (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_quasiquote_bar ((kind, body) : mt) : CST.quasiquote_bar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_conid ((kind, body) : mt) : CST.conid =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_empty_file ((kind, body) : mt) : CST.empty_file =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_varid ((kind, body) : mt) : CST.varid =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_carrow ((kind, body) : mt) : CST.carrow =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `UNKUNKUNK (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `EQGT (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_safety ((kind, body) : mt) : CST.safety =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Unsafe (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Safe (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inte (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tok_barrbrack ((kind, body) : mt) : CST.tok_barrbrack =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quasiquote_body ((kind, body) : mt) : CST.quasiquote_body =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quasiquote_start ((kind, body) : mt) : CST.quasiquote_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_calling_convention ((kind, body) : mt) : CST.calling_convention =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ccall (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Stdc (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Cpluss (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Jvm (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Dotnet (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Prim (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Capi (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_layout_start ((kind, body) : mt) : CST.layout_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_splice_dollar ((kind, body) : mt) : CST.splice_dollar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_strict ((kind, body) : mt) : CST.strict =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_wildcard ((kind, body) : mt) : CST.pat_wildcard =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_label ((kind, body) : mt) : CST.label =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_layout_end ((kind, body) : mt) : CST.layout_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_integer_literal ((kind, body) : mt) : CST.integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_forall_kw ((kind, body) : mt) : CST.forall_kw =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Forall (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `UNKUNKUNK (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_implicit_parid ((kind, body) : mt) : CST.implicit_parid =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tyconsym ((kind, body) : mt) : CST.tyconsym =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_operator ((kind, body) : mt) : CST.operator =
  match body with
  | Children v ->
      trans_varsym (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_tycon_arrow ((kind, body) : mt) : CST.tycon_arrow =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_arrow (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_forall_dot ((kind, body) : mt) : CST.forall_dot =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Arrow (
            trans_arrow (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constructor_operator ((kind, body) : mt) : CST.constructor_operator =
  match body with
  | Children v ->
      trans_consym (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_con_tuple ((kind, body) : mt) : CST.con_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_comma (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constructor ((kind, body) : mt) : CST.constructor =
  match body with
  | Children v ->
      trans_conid (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_variable ((kind, body) : mt) : CST.variable =
  match body with
  | Children v ->
      trans_varid (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_type_variable ((kind, body) : mt) : CST.type_variable =
  match body with
  | Children v ->
      trans_varid (Run.matcher_token v)
  | Leaf _ -> assert false


let trans_impent ((kind, body) : mt) : CST.impent =
  match body with
  | Children v ->
      trans_string_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_expent ((kind, body) : mt) : CST.expent =
  match body with
  | Children v ->
      trans_string_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_foreign_pre ((kind, body) : mt) : CST.foreign_pre =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_calling_convention (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_safety (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_integer ((kind, body) : mt) : CST.integer =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bin_lit (
            trans_binary_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Int_lit (
            trans_integer_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Octal_lit (
            trans_octal_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Hex_lit (
            trans_hex_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_type_operator ((kind, body) : mt) : CST.type_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tyco (
            trans_tyconsym (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Cons_op (
            trans_constructor_operator (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_modid ((kind, body) : mt) : CST.modid =
  match body with
  | Children v ->
      trans_constructor (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_ticked_tycon ((kind, body) : mt) : CST.ticked_tycon =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_constructor (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_name ((kind, body) : mt) : CST.name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_var (
            (match v with
            | Alt (0, v) ->
                `Var (
                  trans_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_choice_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Op (
                              trans_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Minus (
                              trans_minus (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_cons (
            (match v with
            | Alt (0, v) ->
                `Cons (
                  trans_constructor (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_cons_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_constructor_operator (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fun_name ((kind, body) : mt) : CST.fun_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_var (
            (match v with
            | Alt (0, v) ->
                `Var (
                  trans_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_choice_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Op (
                              trans_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Minus (
                              trans_minus (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Impl_parid (
            trans_implicit_parid (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_varop ((kind, body) : mt) : CST.varop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_op (
            (match v with
            | Alt (0, v) ->
                `Op (
                  trans_operator (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Minus (
                  trans_minus (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `BQUOT_var_BQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_variable (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_name ((kind, body) : mt) : CST.import_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_cons (
            (match v with
            | Alt (0, v) ->
                `Cons (
                  trans_constructor (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_cons_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_constructor_operator (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_var (
            (match v with
            | Alt (0, v) ->
                `Var (
                  trans_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_choice_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Op (
                              trans_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Minus (
                              trans_minus (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_name ((kind, body) : mt) : CST.pat_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Var (
            trans_variable (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LPAR_choice_op_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Op (
                        trans_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Minus (
                        trans_minus (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_fundep ((kind, body) : mt) : CST.fundep =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.repeat1
              (fun v -> trans_type_variable (Run.matcher_token v))
              v0
            ,
            trans_arrow (Run.matcher_token v1),
            Run.repeat1
              (fun v -> trans_type_variable (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tyfam_injectivity ((kind, body) : mt) : CST.tyfam_injectivity =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_variable (Run.matcher_token v1),
            trans_arrow (Run.matcher_token v2),
            Run.repeat1
              (fun v -> trans_type_variable (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_str (
            (match v with
            | Alt (0, v) ->
                `Str (
                  trans_string_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Char (
                  trans_char (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_int (
            (match v with
            | Alt (0, v) ->
                `Int (
                  trans_integer (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Float (
                  trans_float_ (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_qualified_type_operator ((kind, body) : mt) : CST.qualified_type_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_tyconsym (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qualified_constructor ((kind, body) : mt) : CST.qualified_constructor =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_constructor (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qualified_variable ((kind, body) : mt) : CST.qualified_variable =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_variable (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qualified_module ((kind, body) : mt) : CST.qualified_module =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_modid (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qualified_operator ((kind, body) : mt) : CST.qualified_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Op (
                  trans_operator (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Minus (
                  trans_minus (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qualified_type ((kind, body) : mt) : CST.qualified_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_constructor (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_do_module ((kind, body) : mt) : CST.do_module =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_do_keyword (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qualified_constructor_operator ((kind, body) : mt) : CST.qualified_constructor_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_modid (Run.matcher_token v0),
                      trans_dot (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_constructor_operator (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_export_names ((kind, body) : mt) : CST.export_names =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `DOTDOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Opt_name_rep_comma_name (
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_name (Run.matcher_token v0),
                                Run.repeat
                                  (fun v ->
                                    (match v with
                                    | Seq [v0; v1] ->
                                        (
                                          trans_comma (Run.matcher_token v0),
                                          trans_name (Run.matcher_token v1)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                                  v1
                              )
                          | _ -> assert false
                          )
                        )
                        v
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fixity ((kind, body) : mt) : CST.fixity =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Infixl (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Infixr (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Infix (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_integer (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Varop (
                  trans_varop (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_cons_op (
                  (match v with
                  | Alt (0, v) ->
                      `Cons_op (
                        trans_constructor_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `BQUOT_cons_BQUOT (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              trans_constructor (Run.matcher_token v1),
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Varop (
                            trans_varop (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Choice_cons_op (
                            (match v with
                            | Alt (0, v) ->
                                `Cons_op (
                                  trans_constructor_operator (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `BQUOT_cons_BQUOT (
                                  (match v with
                                  | Seq [v0; v1; v2] ->
                                      (
                                        Run.trans_token (Run.matcher_token v0),
                                        trans_constructor (Run.matcher_token v1),
                                        Run.trans_token (Run.matcher_token v2)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_import_con_names ((kind, body) : mt) : CST.import_con_names =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `DOTDOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Import_name_rep_comma_import_name (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_import_name (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_comma (Run.matcher_token v0),
                                      trans_import_name (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fundeps ((kind, body) : mt) : CST.fundeps =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_fundep (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_fundep (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_literal ((kind, body) : mt) : CST.type_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Con_unit (
            trans_con_unit (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Con_list (
            trans_con_list (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Con_tuple (
            trans_con_tuple (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal_ ((kind, body) : mt) : CST.literal_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_con_unit (
            (match v with
            | Alt (0, v) ->
                `Con_unit (
                  trans_con_unit (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Con_list (
                  trans_con_list (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Con_tuple (
                  trans_con_tuple (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_quasiquote ((kind, body) : mt) : CST.quasiquote =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `UNKUNKUNK (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Quas_start_opt_choice_qual_var_quas_bar (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_quasiquote_start (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Alt (0, v) ->
                                `Qual_var (
                                  trans_qualified_variable (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Var (
                                  trans_variable (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        trans_quasiquote_bar (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_quasiquote_body (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Tok_barr (
                  trans_tok_barrbrack (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `UNKUNKUNK (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qmodid ((kind, body) : mt) : CST.qmodid =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Qual_module (
            trans_qualified_module (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Modid (
            trans_modid (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qvarop_nominus ((kind, body) : mt) : CST.qvarop_nominus =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_qual_op (
            (match v with
            | Alt (0, v) ->
                `Qual_op (
                  trans_qualified_operator (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Op (
                  trans_operator (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `BQUOT_choice_qual_var_BQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Qual_var (
                        trans_qualified_variable (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Var (
                        trans_variable (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qvarop ((kind, body) : mt) : CST.qvarop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_qual_op (
            (match v with
            | Alt (0, v) ->
                `Qual_op (
                  trans_qualified_operator (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_op (
                  (match v with
                  | Alt (0, v) ->
                      `Op (
                        trans_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Minus (
                        trans_minus (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `BQUOT_choice_qual_var_BQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Qual_var (
                        trans_qualified_variable (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Var (
                        trans_variable (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_ticked_qtycon ((kind, body) : mt) : CST.ticked_qtycon =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Qual_type (
                  trans_qualified_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Cons (
                  trans_constructor (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qualified_type_operator_ ((kind, body) : mt) : CST.qualified_type_operator_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Qual_type_op (
            trans_qualified_type_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Qual_cons_op (
            trans_qualified_constructor_operator (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qcon ((kind, body) : mt) : CST.qcon =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_qual_cons (
            (match v with
            | Alt (0, v) ->
                `Qual_cons (
                  trans_qualified_constructor (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Cons (
                  trans_constructor (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_choice_qual_cons_op_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Qual_cons_op (
                        trans_qualified_constructor_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons_op (
                        trans_constructor_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_import_item ((kind, body) : mt) : CST.import_item =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_namespace (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Choice_var (
                  (match v with
                  | Alt (0, v) ->
                      `Var (
                        trans_variable (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `LPAR_choice_op_RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Op (
                                    trans_operator (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Minus (
                                    trans_minus (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Choice_cons_opt_import_con_names (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Cons (
                              trans_constructor (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `LPAR_type_op_RPAR (
                              (match v with
                              | Seq [v0; v1; v2] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    trans_type_operator (Run.matcher_token v1),
                                    Run.trans_token (Run.matcher_token v2)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.opt
                          (fun v -> trans_import_con_names (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qop ((kind, body) : mt) : CST.qop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Qvarop (
            trans_qvarop (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_choice_qual_cons_op (
            (match v with
            | Alt (0, v) ->
                `Choice_qual_cons_op (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_cons_op (
                        trans_qualified_constructor_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons_op (
                        trans_constructor_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `BQUOT_choice_qual_cons_BQUOT (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Qual_cons (
                              trans_qualified_constructor (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Cons (
                              trans_constructor (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qtyconops ((kind, body) : mt) : CST.qtyconops =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ticked_qtycon (
            trans_ticked_qtycon (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_qual_type_op_ (
            (match v with
            | Alt (0, v) ->
                `Qual_type_op_ (
                  trans_qualified_type_operator_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_op (
                  trans_type_operator (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_role ((kind, body) : mt) : CST.decl_role =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Choice_qual_type (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_type (
                        trans_qualified_type (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons (
                        trans_constructor (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `LPAR_choice_qual_type_op__RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Qual_type_op_ (
                              trans_qualified_type_operator_ (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Type_op (
                              trans_type_operator (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.repeat1
              (fun v -> trans_type_role (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_export ((kind, body) : mt) : CST.export =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_choice_qual_var (
            (match v with
            | Alt (0, v) ->
                `Choice_qual_var (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_var (
                        trans_qualified_variable (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Var (
                        trans_variable (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `LPAR_choice_qual_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Qual_op (
                              trans_qualified_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Choice_op (
                              (match v with
                              | Alt (0, v) ->
                                  `Op (
                                    trans_operator (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Minus (
                                    trans_minus (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_name_choice_choice_qual_type_opt_export_names (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_namespace (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Choice_qual_type (
                        (match v with
                        | Alt (0, v) ->
                            `Qual_type (
                              trans_qualified_type (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Cons (
                              trans_constructor (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `LPAR_choice_qual_type_op__RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Qual_type_op_ (
                                    trans_qualified_type_operator_ (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Type_op (
                                    trans_type_operator (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> trans_export_names (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Module_qmodid (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_qmodid (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_promoted_tycon ((kind, body) : mt) : CST.promoted_tycon =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Choice_qual_type (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_type (
                        trans_qualified_type (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons (
                        trans_constructor (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `LPAR_choice_qual_type_op__RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Qual_type_op_ (
                              trans_qualified_type_operator_ (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Type_op (
                              trans_type_operator (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_exp_name ((kind, body) : mt) : CST.exp_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_choice_qual_var (
            (match v with
            | Alt (0, v) ->
                `Choice_qual_var (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_var (
                        trans_qualified_variable (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Var (
                        trans_variable (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `LPAR_choice_qual_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Qual_op (
                              trans_qualified_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Choice_op (
                              (match v with
                              | Alt (0, v) ->
                                  `Op (
                                    trans_operator (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Minus (
                                    trans_minus (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Qcon (
            trans_qcon (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Impl_parid (
            trans_implicit_parid (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Label (
            trans_label (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_constructor ((kind, body) : mt) : CST.pat_constructor =
  match body with
  | Children v ->
      trans_qcon (Run.matcher_token v)
  | Leaf _ -> assert false



let trans_import_list ((kind, body) : mt) : CST.import_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_import_item (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                trans_import_item (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> trans_comma (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_promoted_tyconop ((kind, body) : mt) : CST.promoted_tyconop =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_qtyconops (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_exports ((kind, body) : mt) : CST.exports =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_export (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                trans_export (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_comma (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_decl_import ((kind, body) : mt) : CST.decl_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_string_ (Run.matcher_token v))
              v2
            ,
            trans_qmodid (Run.matcher_token v3),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_qmodid (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.opt
              (fun v -> trans_import_list (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_qtyconop ((kind, body) : mt) : CST.qtyconop =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prom_tyco (
            trans_promoted_tyconop (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Qtycos (
            trans_qtyconops (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_aexp ((kind, body) : mt) : CST.aexp =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_name (
            trans_exp_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_parens (
            trans_exp_parens (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Exp_tuple_ (
            trans_exp_tuple_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Exp_list (
            trans_exp_list (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Exp_th_quoted_name (
            trans_exp_th_quoted_name (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Exp_type_app (
            trans_exp_type_application (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Exp_lambda_case (
            trans_exp_lambda_case (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Exp_do (
            trans_exp_do (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Exp_record (
            trans_exp_record (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Exp_arit_seq (
            trans_exp_arithmetic_sequence (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Exp_list_comp (
            trans_exp_list_comprehension (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Exp_sect_left (
            trans_exp_section_left (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Exp_sect_right (
            trans_exp_section_right (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Exp_unbo_tuple (
            trans_exp_unboxed_tuple (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Exp_unbo_sum_ (
            trans_exp_unboxed_sum_ (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Splice (
            trans_splice (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Quas (
            trans_quasiquote (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Lit_ (
            trans_literal_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_alt ((kind, body) : mt) : CST.alt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat (Run.matcher_token v0),
            trans_alt_variants (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_where (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_decls (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_alt_variants ((kind, body) : mt) : CST.alt_variants =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Arrow_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_arrow (Run.matcher_token v0),
                  trans_exp (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Rep1_gdpat (
            Run.repeat1
              (fun v -> trans_gdpat (Run.matcher_token v))
              v
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_alts ((kind, body) : mt) : CST.alts =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LCURL_opt_alt_rep_SEMI_alt_opt_SEMI_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_alt (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_alt (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Layout_start_opt_alt_rep_choice_SEMI_alt_opt_choice_SEMI_layout_end (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_layout_start (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_alt (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      (match v0 with
                                      | Alt (0, v) ->
                                          `SEMI (
                                            Run.trans_token (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Layout_semi (
                                            trans_layout_semicolon (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                      ,
                                      trans_alt (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v ->
                                (match v with
                                | Alt (0, v) ->
                                    `SEMI (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Layout_semi (
                                      trans_layout_semicolon (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                              v2
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  trans_layout_end (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotated_type_variable ((kind, body) : mt) : CST.annotated_type_variable =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_variable (Run.matcher_token v1),
            trans_type_annotation (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_apat ((kind, body) : mt) : CST.apat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_name (
            trans_pat_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_as (
            trans_pat_as (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_cons (
            trans_pat_constructor (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_record (
            trans_pat_record (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Lit_ (
            trans_literal_ (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pat_wild (
            trans_pat_wildcard (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Pat_parens (
            trans_pat_parens (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Pat_tuple (
            trans_pat_tuple (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Pat_unbo_tuple (
            trans_pat_unboxed_tuple (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Pat_unbo_sum_ (
            trans_pat_unboxed_sum_ (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Pat_list (
            trans_pat_list (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Pat_strict (
            trans_pat_strict (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Pat_irre (
            trans_pat_irrefutable (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Splice (
            trans_splice (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Quas (
            trans_quasiquote (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_atype ((kind, body) : mt) : CST.atype =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_name (
            trans_type_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_star (
            trans_type_star (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Type_lit_ (
            trans_type_literal_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Type_parens (
            trans_type_parens (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Type_unbo_tuple (
            trans_type_unboxed_tuple (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Type_unbo_sum (
            trans_type_unboxed_sum (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Splice (
            trans_splice (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Quas (
            trans_quasiquote (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_pattern ((kind, body) : mt) : CST.bind_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_typed_pat (Run.matcher_token v0),
            trans_larrow (Run.matcher_token v1),
            trans_exp (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_btype ((kind, body) : mt) : CST.btype =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Atype (
            trans_atype (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_apply (
            trans_type_apply (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constraint_ ((kind, body) : mt) : CST.constraint_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_name_rep_atype (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_type_name (Run.matcher_token v0),
                  Run.repeat
                    (fun v -> trans_atype (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Type_infix_ (
            trans_type_infix_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constraint__ ((kind, body) : mt) : CST.constraint__ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Quan_cons (
            trans_quantified_constraint (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Cons_cont (
            trans_constraint_context (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `LPAR_cons__RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_constraint__ (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Cons (
            trans_constraint_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constraint_context ((kind, body) : mt) : CST.constraint_context =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_context (Run.matcher_token v0),
            trans_constraint__ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_context ((kind, body) : mt) : CST.context =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_context_constraints (Run.matcher_token v0),
            trans_carrow (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_context_constraints ((kind, body) : mt) : CST.context_constraints =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Cons (
                  trans_constraint_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_opt_choice_cons__rep_comma_choice_cons__RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  (match v0 with
                                  | Alt (0, v) ->
                                      `Cons_ (
                                        trans_constraint__ (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Impl_param (
                                        trans_implicit_param (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                  ,
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            trans_comma (Run.matcher_token v0),
                                            (match v1 with
                                            | Alt (0, v) ->
                                                `Cons_ (
                                                  trans_constraint__ (Run.matcher_token v)
                                                )
                                            | Alt (1, v) ->
                                                `Impl_param (
                                                  trans_implicit_param (Run.matcher_token v)
                                                )
                                            | _ -> assert false
                                            )
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_decl ((kind, body) : mt) : CST.decl =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Gend (
            trans_gendecl (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Decl_fun (
            trans_decl_fun (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_decl_fun ((kind, body) : mt) : CST.decl_fun =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func (
            trans_function_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Funpat (
            trans_funpat (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_decls ((kind, body) : mt) : CST.decls =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_decl (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_decl (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Layout_start_opt_decl_rep_choice_SEMI_decl_opt_choice_SEMI_layout_end (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_layout_start (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_decl (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      (match v0 with
                                      | Alt (0, v) ->
                                          `SEMI (
                                            Run.trans_token (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Layout_semi (
                                            trans_layout_semicolon (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                      ,
                                      trans_decl (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v ->
                                (match v with
                                | Alt (0, v) ->
                                    `SEMI (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Layout_semi (
                                      trans_layout_semicolon (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                              v2
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  trans_layout_end (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp ((kind, body) : mt) : CST.exp =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_exp_infix (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_annotation (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_apply ((kind, body) : mt) : CST.exp_apply =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Aexp (
            trans_aexp (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Aexp_exp_apply (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_aexp (Run.matcher_token v0),
                  trans_exp_apply (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Aexp_exp_lambda (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_aexp (Run.matcher_token v0),
                  trans_exp_lambda (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Aexp_exp_let_in (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_aexp (Run.matcher_token v0),
                  trans_exp_let_in (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Aexp_exp_cond (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_aexp (Run.matcher_token v0),
                  trans_exp_cond (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Aexp_exp_case (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_aexp (Run.matcher_token v0),
                  trans_exp_case (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_arithmetic_sequence ((kind, body) : mt) : CST.exp_arithmetic_sequence =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_exp (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_exp (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_case ((kind, body) : mt) : CST.exp_case =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_alts (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_cond ((kind, body) : mt) : CST.exp_cond =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_exp (Run.matcher_token v4),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6),
            trans_exp (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_do ((kind, body) : mt) : CST.exp_do =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Do_module (
                  trans_do_module (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Do_kw (
                  trans_do_keyword (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_stmt (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_stmt (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Layout_start_opt_stmt_rep_choice_SEMI_stmt_opt_choice_SEMI_layout_end (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_layout_start (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  trans_stmt (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            (match v0 with
                                            | Alt (0, v) ->
                                                `SEMI (
                                                  Run.trans_token (Run.matcher_token v)
                                                )
                                            | Alt (1, v) ->
                                                `Layout_semi (
                                                  trans_layout_semicolon (Run.matcher_token v)
                                                )
                                            | _ -> assert false
                                            )
                                            ,
                                            trans_stmt (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                  ,
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Alt (0, v) ->
                                          `SEMI (
                                            Run.trans_token (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Layout_semi (
                                            trans_layout_semicolon (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        trans_layout_end (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_field ((kind, body) : mt) : CST.exp_field =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOTDOT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_choice_qual_var_opt_EQ_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Choice_qual_var (
                        (match v with
                        | Alt (0, v) ->
                            `Qual_var (
                              trans_qualified_variable (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Var (
                              trans_variable (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `LPAR_choice_qual_op_RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Qual_op (
                                    trans_qualified_operator (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Choice_op (
                                    (match v with
                                    | Alt (0, v) ->
                                        `Op (
                                          trans_operator (Run.matcher_token v)
                                        )
                                    | Alt (1, v) ->
                                        `Minus (
                                          trans_minus (Run.matcher_token v)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                              | _ -> assert false
                              )
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_exp (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_if_guard ((kind, body) : mt) : CST.exp_if_guard =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_gdpat (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_in ((kind, body) : mt) : CST.exp_in =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_infix ((kind, body) : mt) : CST.exp_infix =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_infix_ (
            trans_exp_infix_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Lexp (
            trans_lexp (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_infix_ ((kind, body) : mt) : CST.exp_infix_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exp_infix (Run.matcher_token v0),
            trans_qop (Run.matcher_token v1),
            trans_lexp (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_lambda ((kind, body) : mt) : CST.exp_lambda =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_apat (Run.matcher_token v))
              v1
            ,
            trans_arrow (Run.matcher_token v2),
            trans_exp (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_lambda_case ((kind, body) : mt) : CST.exp_lambda_case =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_alts (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_let ((kind, body) : mt) : CST.exp_let =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_let_decls (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_let_in ((kind, body) : mt) : CST.exp_let_in =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_exp_let (Run.matcher_token v0),
            trans_exp_in (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_list ((kind, body) : mt) : CST.exp_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_exp (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_list_comprehension ((kind, body) : mt) : CST.exp_list_comprehension =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_qual (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_qual (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_negation ((kind, body) : mt) : CST.exp_negation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_aexp (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_parens ((kind, body) : mt) : CST.exp_parens =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_record ((kind, body) : mt) : CST.exp_record =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_aexp (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_exp_field (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_exp_field (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_section_left ((kind, body) : mt) : CST.exp_section_left =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp_infix (Run.matcher_token v1),
            trans_qop (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_section_right ((kind, body) : mt) : CST.exp_section_right =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Qvarop_nominus (
                  trans_qvarop_nominus (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_choice_qual_cons_op (
                  (match v with
                  | Alt (0, v) ->
                      `Choice_qual_cons_op (
                        (match v with
                        | Alt (0, v) ->
                            `Qual_cons_op (
                              trans_qualified_constructor_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Cons_op (
                              trans_constructor_operator (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `BQUOT_choice_qual_cons_BQUOT (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Qual_cons (
                                    trans_qualified_constructor (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Cons (
                                    trans_constructor (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_exp_infix (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_th_quoted_name ((kind, body) : mt) : CST.exp_th_quoted_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `SQUOT_choice_choice_choice_qual_var (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Choice_choice_qual_var (
                        (match v with
                        | Alt (0, v) ->
                            `Choice_qual_var (
                              (match v with
                              | Alt (0, v) ->
                                  `Qual_var (
                                    trans_qualified_variable (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Var (
                                    trans_variable (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                            )
                        | Alt (1, v) ->
                            `LPAR_choice_qual_op_RPAR (
                              (match v with
                              | Seq [v0; v1; v2] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    (match v1 with
                                    | Alt (0, v) ->
                                        `Qual_op (
                                          trans_qualified_operator (Run.matcher_token v)
                                        )
                                    | Alt (1, v) ->
                                        `Choice_op (
                                          (match v with
                                          | Alt (0, v) ->
                                              `Op (
                                                trans_operator (Run.matcher_token v)
                                              )
                                          | Alt (1, v) ->
                                              `Minus (
                                                trans_minus (Run.matcher_token v)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                    | _ -> assert false
                                    )
                                    ,
                                    Run.trans_token (Run.matcher_token v2)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `Qcon (
                        trans_qcon (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `SQUOTSQUOT_atype (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_atype (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_tuple ((kind, body) : mt) : CST.exp_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Rep1_comma_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v -> trans_comma (Run.matcher_token v))
                          v0
                        ,
                        trans_exp (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Exp_comma_opt_exp (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_exp (Run.matcher_token v0),
                        trans_comma (Run.matcher_token v1),
                        Run.opt
                          (fun v -> trans_exp (Run.matcher_token v))
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_exp (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_tuple_ ((kind, body) : mt) : CST.exp_tuple_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_exp_tuple (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_type_application ((kind, body) : mt) : CST.exp_type_application =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_atype (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_unboxed_sum ((kind, body) : mt) : CST.exp_unboxed_sum =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_exp (Run.matcher_token v))
              v0
            ,
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_exp (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_unboxed_sum_ ((kind, body) : mt) : CST.exp_unboxed_sum_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unboxed_open (Run.matcher_token v0),
            trans_exp_unboxed_sum (Run.matcher_token v1),
            trans_unboxed_close (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_unboxed_tuple ((kind, body) : mt) : CST.exp_unboxed_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unboxed_open (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_exp (Run.matcher_token v))
                        v0
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                Run.opt
                                  (fun v -> trans_exp (Run.matcher_token v))
                                  v1
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_unboxed_close (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_fexp ((kind, body) : mt) : CST.fexp =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Aexp (
            trans_aexp (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_apply (
            trans_exp_apply (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_forall ((kind, body) : mt) : CST.forall =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_forall_kw (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Anno_type_var (
                      trans_annotated_type_variable (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Type_var (
                      trans_type_variable (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_fun_arrow ((kind, body) : mt) : CST.fun_arrow =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_modifier (Run.matcher_token v))
              v0
            ,
            trans_arrow (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_fun_guards ((kind, body) : mt) : CST.fun_guards =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_guard_equation (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_fun_patterns ((kind, body) : mt) : CST.fun_patterns =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_apat (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_function_ ((kind, body) : mt) : CST.function_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_funlhs (Run.matcher_token v0),
            trans_funrhs (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_funlhs ((kind, body) : mt) : CST.funlhs =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Funvar (
            trans_funvar (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Funpat_infix (
            trans_funpat_infix (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_funpat ((kind, body) : mt) : CST.funpat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_typed_pat (Run.matcher_token v0),
            trans_funrhs (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_funpat_infix ((kind, body) : mt) : CST.funpat_infix =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat (Run.matcher_token v0),
            trans_varop (Run.matcher_token v1),
            trans_pat (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_funrhs ((kind, body) : mt) : CST.funrhs =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `EQ_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_exp (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Fun_guards (
                  trans_fun_guards (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_where (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_decls (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_funvar ((kind, body) : mt) : CST.funvar =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_fun_name (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_fun_patterns (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_gdpat ((kind, body) : mt) : CST.gdpat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_guards (Run.matcher_token v0),
            trans_arrow (Run.matcher_token v1),
            trans_exp (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_gendecl ((kind, body) : mt) : CST.gendecl =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Sign (
            trans_signature (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Fixity (
            trans_fixity (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_guard ((kind, body) : mt) : CST.guard =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_guard (
            trans_pattern_guard (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Let (
            trans_let_ (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Exp_infix (
            trans_exp_infix (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_guard_equation ((kind, body) : mt) : CST.guard_equation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_guards (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_exp (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_guards ((kind, body) : mt) : CST.guards =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_guard (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_guard (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_implicit_param ((kind, body) : mt) : CST.implicit_param =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_implicit_parid (Run.matcher_token v0),
            trans_type_annotation (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_let_ ((kind, body) : mt) : CST.let_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_decls (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_let_decls ((kind, body) : mt) : CST.let_decls =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_decl (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_decl (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Layout_start_opt_decl_rep_choice_SEMI_decl_opt_choice_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_layout_start (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_decl (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      (match v0 with
                                      | Alt (0, v) ->
                                          `SEMI (
                                            Run.trans_token (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Layout_semi (
                                            trans_layout_semicolon (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                      ,
                                      trans_decl (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v ->
                                (match v with
                                | Alt (0, v) ->
                                    `SEMI (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Layout_semi (
                                      trans_layout_semicolon (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                              v2
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lexp ((kind, body) : mt) : CST.lexp =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_let_in (
            trans_exp_let_in (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_cond (
            trans_exp_cond (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Exp_if_guard (
            trans_exp_if_guard (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Exp_case (
            trans_exp_case (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Exp_nega (
            trans_exp_negation (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Fexp (
            trans_fexp (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Exp_lambda (
            trans_exp_lambda (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lpat ((kind, body) : mt) : CST.lpat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Apat (
            trans_apat (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_nega (
            trans_pat_negation (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_apply (
            trans_pat_apply (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_modifier ((kind, body) : mt) : CST.modifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_atype (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_nested_pat ((kind, body) : mt) : CST.nested_pat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Typed_pat (
            trans_typed_pat (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_view (
            trans_pat_view (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat ((kind, body) : mt) : CST.pat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_infix (
            trans_pat_infix (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Lpat (
            trans_lpat (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_apply ((kind, body) : mt) : CST.pat_apply =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_constructor (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_apat (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_as ((kind, body) : mt) : CST.pat_as =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_variable (Run.matcher_token v0),
            trans_imm_tok_at (Run.matcher_token v1),
            trans_apat (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_field ((kind, body) : mt) : CST.pat_field =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOTDOT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_choice_qual_var_opt_EQ_nested_pat (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Choice_qual_var (
                        (match v with
                        | Alt (0, v) ->
                            `Qual_var (
                              trans_qualified_variable (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Var (
                              trans_variable (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `LPAR_choice_qual_op_RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Qual_op (
                                    trans_qualified_operator (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Choice_op (
                                    (match v with
                                    | Alt (0, v) ->
                                        `Op (
                                          trans_operator (Run.matcher_token v)
                                        )
                                    | Alt (1, v) ->
                                        `Minus (
                                          trans_minus (Run.matcher_token v)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                              | _ -> assert false
                              )
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_nested_pat (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_fields ((kind, body) : mt) : CST.pat_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_field (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                trans_pat_field (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_infix ((kind, body) : mt) : CST.pat_infix =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_lpat (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Choice_qual_cons_op (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_cons_op (
                        trans_qualified_constructor_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons_op (
                        trans_constructor_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `BQUOT_choice_qual_cons_BQUOT (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Qual_cons (
                              trans_qualified_constructor (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Cons (
                              trans_constructor (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_pat (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_irrefutable ((kind, body) : mt) : CST.pat_irrefutable =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_apat (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_list ((kind, body) : mt) : CST.pat_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_nested_pat (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_nested_pat (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_negation ((kind, body) : mt) : CST.pat_negation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_apat (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_parens ((kind, body) : mt) : CST.pat_parens =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_nested_pat (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_record ((kind, body) : mt) : CST.pat_record =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_constructor (Run.matcher_token v0),
            trans_pat_fields (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_strict ((kind, body) : mt) : CST.pat_strict =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_strict (Run.matcher_token v0),
            trans_apat (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_tuple ((kind, body) : mt) : CST.pat_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_nested_pat (Run.matcher_token v1),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_nested_pat (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_typed ((kind, body) : mt) : CST.pat_typed =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat (Run.matcher_token v0),
            trans_type_annotation (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_unboxed_sum ((kind, body) : mt) : CST.pat_unboxed_sum =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_nested_pat (Run.matcher_token v))
              v0
            ,
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_nested_pat (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_unboxed_sum_ ((kind, body) : mt) : CST.pat_unboxed_sum_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unboxed_open (Run.matcher_token v0),
            trans_pat_unboxed_sum (Run.matcher_token v1),
            trans_unboxed_close (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_unboxed_tuple ((kind, body) : mt) : CST.pat_unboxed_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unboxed_open (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_nested_pat (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                trans_nested_pat (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_unboxed_close (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pat_view ((kind, body) : mt) : CST.pat_view =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_exp (Run.matcher_token v0),
            trans_arrow (Run.matcher_token v1),
            trans_nested_pat (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern_guard ((kind, body) : mt) : CST.pattern_guard =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat (Run.matcher_token v0),
            trans_larrow (Run.matcher_token v1),
            trans_exp_infix (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_qual ((kind, body) : mt) : CST.qual =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bind_pat (
            trans_bind_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Let (
            trans_let_ (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Tran (
            trans_transform (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Exp (
            trans_exp (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantified_constraint ((kind, body) : mt) : CST.quantified_constraint =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_forall (Run.matcher_token v0),
            trans_forall_dot (Run.matcher_token v1),
            trans_constraint__ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_rec_ ((kind, body) : mt) : CST.rec_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_stmt (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_stmt (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Layout_start_opt_stmt_rep_choice_SEMI_stmt_opt_choice_SEMI_layout_end (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_layout_start (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  trans_stmt (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            (match v0 with
                                            | Alt (0, v) ->
                                                `SEMI (
                                                  Run.trans_token (Run.matcher_token v)
                                                )
                                            | Alt (1, v) ->
                                                `Layout_semi (
                                                  trans_layout_semicolon (Run.matcher_token v)
                                                )
                                            | _ -> assert false
                                            )
                                            ,
                                            trans_stmt (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                  ,
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Alt (0, v) ->
                                          `SEMI (
                                            Run.trans_token (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Layout_semi (
                                            trans_layout_semicolon (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v2
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        trans_layout_end (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_signature ((kind, body) : mt) : CST.signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Var (
                  trans_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_choice_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Op (
                              trans_operator (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Minus (
                              trans_minus (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Var (
                            trans_variable (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `LPAR_choice_op_RPAR (
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Op (
                                        trans_operator (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Minus (
                                        trans_minus (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                  ,
                                  Run.trans_token (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_type_annotation (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_splice ((kind, body) : mt) : CST.splice =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_splice_dollar (Run.matcher_token v0),
            trans_splice_exp (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_splice_exp ((kind, body) : mt) : CST.splice_exp =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_name (
            trans_exp_name (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_parens (
            trans_exp_parens (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_stmt ((kind, body) : mt) : CST.stmt =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_exp (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bind_pat (
            trans_bind_pattern (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Let (
            trans_let_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Rec (
            trans_rec_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_transform ((kind, body) : mt) : CST.transform =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Then_exp_using_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_exp (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_exp (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Then_exp_9b4d8a6 (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_exp (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Then_exp_8bf9922 (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_exp (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_quants (
            trans_type_quantifiers (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_cont (
            trans_type_context (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Type_fun (
            trans_type_fun (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Type_infix (
            trans_type_infix (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_annotation ((kind, body) : mt) : CST.type_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_colon2 (Run.matcher_token v0),
            trans_type_or_implicit (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_apply ((kind, body) : mt) : CST.type_apply =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_atype (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_atype (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_context ((kind, body) : mt) : CST.type_context =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_context (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_fun ((kind, body) : mt) : CST.type_fun =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_infix (Run.matcher_token v0),
            trans_fun_arrow (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_infix ((kind, body) : mt) : CST.type_infix =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_infix_ (
            trans_type_infix_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Btype (
            trans_btype (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_infix_ ((kind, body) : mt) : CST.type_infix_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_btype (Run.matcher_token v0),
            trans_qtyconop (Run.matcher_token v1),
            trans_type_infix (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_list ((kind, body) : mt) : CST.type_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_or_implicit (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_type_or_implicit (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_literal_ ((kind, body) : mt) : CST.type_literal_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_prom_lit_c26b94c (
            trans_type_promoted_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_prom_lit_af79c83 (
            trans_type_promotable_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_name ((kind, body) : mt) : CST.type_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_anno_type_var (
            (match v with
            | Alt (0, v) ->
                `Anno_type_var (
                  trans_annotated_type_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_var (
                  trans_type_variable (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_prom_tycon (
            (match v with
            | Alt (0, v) ->
                `Prom_tycon (
                  trans_promoted_tycon (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_choice_qual_type (
                  (match v with
                  | Alt (0, v) ->
                      `Choice_qual_type (
                        (match v with
                        | Alt (0, v) ->
                            `Qual_type (
                              trans_qualified_type (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Cons (
                              trans_constructor (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `LPAR_choice_qual_type_op__RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Qual_type_op_ (
                                    trans_qualified_type_operator_ (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Type_op (
                                    trans_type_operator (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                              ,
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Tycon_arrow (
                  trans_tycon_arrow (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_or_implicit ((kind, body) : mt) : CST.type_or_implicit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Impl_param (
            trans_implicit_param (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type (
            trans_type_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parens ((kind, body) : mt) : CST.type_parens =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_or_implicit (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_promotable_literal ((kind, body) : mt) : CST.type_promotable_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_lit (
            trans_type_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_tuple_ (
            trans_type_tuple_ (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Type_list (
            trans_type_list (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_promoted_literal ((kind, body) : mt) : CST.type_promoted_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_promotable_literal (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_quantifiers ((kind, body) : mt) : CST.type_quantifiers =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_forall (Run.matcher_token v0),
            trans_forall_dot (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_sum ((kind, body) : mt) : CST.type_sum =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_or_implicit (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_or_implicit (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_tuple ((kind, body) : mt) : CST.type_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_or_implicit (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_type_or_implicit (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_tuple_ ((kind, body) : mt) : CST.type_tuple_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_tuple (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_unboxed_sum ((kind, body) : mt) : CST.type_unboxed_sum =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unboxed_open (Run.matcher_token v0),
            trans_type_sum (Run.matcher_token v1),
            trans_unboxed_close (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_unboxed_tuple ((kind, body) : mt) : CST.type_unboxed_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unboxed_open (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_or_implicit (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                trans_type_or_implicit (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_unboxed_close (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typed_pat ((kind, body) : mt) : CST.typed_pat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat (
            trans_pat (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_typed (
            trans_pat_typed (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tyfam_result_type ((kind, body) : mt) : CST.tyfam_result_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Anno_type_var (
                  trans_annotated_type_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_var (
                  trans_type_variable (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_context_ ((kind, body) : mt) : CST.context_ =
  match body with
  | Children v ->
      trans_context (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_default_signature ((kind, body) : mt) : CST.default_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_signature (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_inst_tyinst ((kind, body) : mt) : CST.inst_tyinst =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v -> trans_atype (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_type_ (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_strict_type ((kind, body) : mt) : CST.strict_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_strict (Run.matcher_token v0),
            trans_atype (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pattern_type ((kind, body) : mt) : CST.pattern_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Cons (
                  trans_constructor (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_cons_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_constructor_operator (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_type_annotation (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_default ((kind, body) : mt) : CST.decl_default =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_infix (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_comma (Run.matcher_token v0),
                                trans_type_infix (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_decl_foreign_import ((kind, body) : mt) : CST.decl_foreign_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_foreign_pre (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_impent (Run.matcher_token v))
              v3
            ,
            trans_signature (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pattern_equals ((kind, body) : mt) : CST.pattern_equals =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_pat (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_simpletype_infix ((kind, body) : mt) : CST.simpletype_infix =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Anno_type_var (
                  trans_annotated_type_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_var (
                  trans_type_variable (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `Ticked_tycon (
                  trans_ticked_tycon (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_op (
                  trans_type_operator (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Anno_type_var (
                  trans_annotated_type_variable (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_var (
                  trans_type_variable (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_via ((kind, body) : mt) : CST.via =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_pattern_decl ((kind, body) : mt) : CST.pattern_decl =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat (Run.matcher_token v0),
            trans_funrhs (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_top_splice ((kind, body) : mt) : CST.top_splice =
  match body with
  | Children v ->
      trans_exp_infix (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_decl_tyinst ((kind, body) : mt) : CST.decl_tyinst =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_atype (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_type_or_implicit (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_forall_ ((kind, body) : mt) : CST.forall_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_forall (Run.matcher_token v0),
            trans_forall_dot (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_foreign_export ((kind, body) : mt) : CST.decl_foreign_export =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_foreign_pre (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_expent (Run.matcher_token v))
              v3
            ,
            trans_signature (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tyfam_pat ((kind, body) : mt) : CST.tyfam_pat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_qual_type_rep_atype (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Qual_type (
                        trans_qualified_type (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons (
                        trans_constructor (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.repeat
                    (fun v -> trans_atype (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Btype_qtyc_btype (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_btype (Run.matcher_token v0),
                  trans_qtyconop (Run.matcher_token v1),
                  trans_btype (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tyfam_inj ((kind, body) : mt) : CST.tyfam_inj =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_tyfam_result_type (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_tyfam_injectivity (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field ((kind, body) : mt) : CST.field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_variable (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_variable (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_colon2 (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Strict_type (
                  trans_strict_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_data_constructor ((kind, body) : mt) : CST.data_constructor =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_constructor (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Strict_type (
                      trans_strict_type (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Atype (
                      trans_atype (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_gadt_fun ((kind, body) : mt) : CST.gadt_fun =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Strict_type (
                  trans_strict_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_infix (
                  trans_type_infix (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_arrow (Run.matcher_token v1),
            trans_gadt_sig (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_gadt_sig ((kind, body) : mt) : CST.gadt_sig =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Gadt_fun (
            trans_gadt_fun (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_strict_type (
            (match v with
            | Alt (0, v) ->
                `Strict_type (
                  trans_strict_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_infix (
                  trans_type_infix (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_data_constructor_infix ((kind, body) : mt) : CST.data_constructor_infix =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Strict_type (
                  trans_strict_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_infix (
                  trans_type_infix (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `Cons_op (
                  trans_constructor_operator (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `BQUOT_cons_BQUOT (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_constructor (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Strict_type (
                  trans_strict_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type_infix (
                  trans_type_infix (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_simpletype ((kind, body) : mt) : CST.simpletype =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_simp_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_simpletype (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Simp_infix (
            trans_simpletype_infix (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Choice_cons_rep_choice_anno_type_var (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Cons (
                        trans_constructor (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `LPAR_type_op_RPAR (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              Run.trans_token (Run.matcher_token v0),
                              trans_type_operator (Run.matcher_token v1),
                              Run.trans_token (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Anno_type_var (
                            trans_annotated_type_variable (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Type_var (
                            trans_type_variable (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_deriving ((kind, body) : mt) : CST.deriving =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_deriving_strategy (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Choice_qual_type (
                  (match v with
                  | Alt (0, v) ->
                      `Qual_type (
                        trans_qualified_type (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Cons (
                        trans_constructor (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `LPAR_opt_cons__rep_comma_cons__RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_constraint__ (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            trans_comma (Run.matcher_token v0),
                                            trans_constraint__ (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_via (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pattern_arrow ((kind, body) : mt) : CST.pattern_arrow =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat (Run.matcher_token v0),
            trans_larrow (Run.matcher_token v1),
            trans_pat (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_where (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `LCURL_opt_pat_decl_rep_SEMI_pat_decl_opt_SEMI_RCURL (
                            (match v with
                            | Seq [v0; v1; v2; v3] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            trans_pattern_decl (Run.matcher_token v0),
                                            Run.repeat
                                              (fun v ->
                                                (match v with
                                                | Seq [v0; v1] ->
                                                    (
                                                      Run.trans_token (Run.matcher_token v0),
                                                      trans_pattern_decl (Run.matcher_token v1)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                              v1
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                  ,
                                  Run.opt
                                    (fun v -> Run.trans_token (Run.matcher_token v))
                                    v2
                                  ,
                                  Run.trans_token (Run.matcher_token v3)
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (1, v) ->
                          `Layout_start_opt_pat_decl_rep_choice_SEMI_pat_decl_opt_choice_SEMI_layout_end (
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  trans_layout_start (Run.matcher_token v0),
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1; v2] ->
                                          (
                                            trans_pattern_decl (Run.matcher_token v0),
                                            Run.repeat
                                              (fun v ->
                                                (match v with
                                                | Seq [v0; v1] ->
                                                    (
                                                      (match v0 with
                                                      | Alt (0, v) ->
                                                          `SEMI (
                                                            Run.trans_token (Run.matcher_token v)
                                                          )
                                                      | Alt (1, v) ->
                                                          `Layout_semi (
                                                            trans_layout_semicolon (Run.matcher_token v)
                                                          )
                                                      | _ -> assert false
                                                      )
                                                      ,
                                                      trans_pattern_decl (Run.matcher_token v1)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                              v1
                                            ,
                                            Run.opt
                                              (fun v ->
                                                (match v with
                                                | Alt (0, v) ->
                                                    `SEMI (
                                                      Run.trans_token (Run.matcher_token v)
                                                    )
                                                | Alt (1, v) ->
                                                    `Layout_semi (
                                                      trans_layout_semicolon (Run.matcher_token v)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                              v2
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                  ,
                                  trans_layout_end (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_datainst ((kind, body) : mt) : CST.datainst =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_forall_ (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_context_ (Run.matcher_token v))
              v1
            ,
            trans_type_infix (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_annotation (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_instance ((kind, body) : mt) : CST.instance =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_forall_ (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_context_ (Run.matcher_token v))
              v2
            ,
            trans_constraint_ (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_foreign ((kind, body) : mt) : CST.decl_foreign =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Decl_fore_import (
            trans_decl_foreign_import (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Decl_fore_export (
            trans_decl_foreign_export (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tyfam_eq ((kind, body) : mt) : CST.tyfam_eq =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_tyfam_pat (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_or_implicit (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_record_fields ((kind, body) : mt) : CST.record_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_field (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_field (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_record_field ((kind, body) : mt) : CST.record_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_field (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_context_newtype ((kind, body) : mt) : CST.context_newtype =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cont__simp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_context_ (Run.matcher_token v0),
                  trans_simpletype (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Simp (
            trans_simpletype (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_tyfam ((kind, body) : mt) : CST.class_tyfam =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_simpletype (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_annotation (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tyfam_head ((kind, body) : mt) : CST.tyfam_head =
  match body with
  | Children v ->
      trans_simpletype (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_decl_datafam ((kind, body) : mt) : CST.decl_datafam =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_simpletype (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_annotation (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_type ((kind, body) : mt) : CST.decl_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_simpletype (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `EQ_type_or_impl (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_type_or_implicit (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Type_anno (
                  trans_type_annotation (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_datafam ((kind, body) : mt) : CST.class_datafam =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_simpletype (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_annotation (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_pattern ((kind, body) : mt) : CST.decl_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Pat_type (
                  trans_pattern_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_equals (
                  trans_pattern_equals (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Pat_arrow (
                  trans_pattern_arrow (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_deriving ((kind, body) : mt) : CST.decl_deriving =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Deri_stra (
                      trans_deriving_strategy (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Via (
                      trans_via (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_instance (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_data_constructor_record ((kind, body) : mt) : CST.data_constructor_record =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_constructor (Run.matcher_token v0),
            trans_record_fields (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_gadt_constr_type ((kind, body) : mt) : CST.gadt_constr_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_colon2 (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_forall_ (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_context_ (Run.matcher_token v))
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `Gadt_sig (
                  trans_gadt_sig (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Record_fields_arrow_gadt_sig (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_record_fields (Run.matcher_token v0),
                        trans_arrow (Run.matcher_token v1),
                        trans_gadt_sig (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_newtype_constructor ((kind, body) : mt) : CST.newtype_constructor =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_constructor (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Atype (
                  trans_atype (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Record_field (
                  trans_record_field (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_tyfam ((kind, body) : mt) : CST.decl_tyfam =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_tyfam_head (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Type_anno (
                      trans_type_annotation (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Tyfam_inj (
                      trans_tyfam_inj (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_where (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Alt (0, v) ->
                              `LCURL_opt_tyfam_eq_rep_SEMI_tyfam_eq_opt_SEMI_RCURL (
                                (match v with
                                | Seq [v0; v1; v2; v3] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                trans_tyfam_eq (Run.matcher_token v0),
                                                Run.repeat
                                                  (fun v ->
                                                    (match v with
                                                    | Seq [v0; v1] ->
                                                        (
                                                          Run.trans_token (Run.matcher_token v0),
                                                          trans_tyfam_eq (Run.matcher_token v1)
                                                        )
                                                    | _ -> assert false
                                                    )
                                                  )
                                                  v1
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      Run.opt
                                        (fun v -> Run.trans_token (Run.matcher_token v))
                                        v2
                                      ,
                                      Run.trans_token (Run.matcher_token v3)
                                    )
                                | _ -> assert false
                                )
                              )
                          | Alt (1, v) ->
                              `Layout_start_opt_tyfam_eq_rep_choice_SEMI_tyfam_eq_opt_choice_SEMI_layout_end (
                                (match v with
                                | Seq [v0; v1; v2] ->
                                    (
                                      trans_layout_start (Run.matcher_token v0),
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1; v2] ->
                                              (
                                                trans_tyfam_eq (Run.matcher_token v0),
                                                Run.repeat
                                                  (fun v ->
                                                    (match v with
                                                    | Seq [v0; v1] ->
                                                        (
                                                          (match v0 with
                                                          | Alt (0, v) ->
                                                              `SEMI (
                                                                Run.trans_token (Run.matcher_token v)
                                                              )
                                                          | Alt (1, v) ->
                                                              `Layout_semi (
                                                                trans_layout_semicolon (Run.matcher_token v)
                                                              )
                                                          | _ -> assert false
                                                          )
                                                          ,
                                                          trans_tyfam_eq (Run.matcher_token v1)
                                                        )
                                                    | _ -> assert false
                                                    )
                                                  )
                                                  v1
                                                ,
                                                Run.opt
                                                  (fun v ->
                                                    (match v with
                                                    | Alt (0, v) ->
                                                        `SEMI (
                                                          Run.trans_token (Run.matcher_token v)
                                                        )
                                                    | Alt (1, v) ->
                                                        `Layout_semi (
                                                          trans_layout_semicolon (Run.matcher_token v)
                                                        )
                                                    | _ -> assert false
                                                    )
                                                  )
                                                  v2
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      trans_layout_end (Run.matcher_token v2)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_cdecl ((kind, body) : mt) : CST.cdecl =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Gend (
            trans_gendecl (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Defa_sign (
            trans_default_signature (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Func (
            trans_function_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Class_tyfam (
            trans_class_tyfam (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Inst_tyinst (
            trans_inst_tyinst (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Class_data (
            trans_class_datafam (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constructors ((kind, body) : mt) : CST.constructors =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_forall_ (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_context_ (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Data_cons (
                  trans_data_constructor (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Data_cons_infix (
                  trans_data_constructor_infix (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Data_cons_record (
                  trans_data_constructor_record (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_forall_ (Run.matcher_token v))
                        v1
                      ,
                      Run.opt
                        (fun v -> trans_context_ (Run.matcher_token v))
                        v2
                      ,
                      (match v3 with
                      | Alt (0, v) ->
                          `Data_cons (
                            trans_data_constructor (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Data_cons_infix (
                            trans_data_constructor_infix (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Data_cons_record (
                            trans_data_constructor_record (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_gadt_constructor ((kind, body) : mt) : CST.gadt_constructor =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Cons (
                  trans_constructor (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_cons_op_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_constructor_operator (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_gadt_constr_type (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_newtype ((kind, body) : mt) : CST.newtype =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_newtype_constructor (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_deriving (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_body ((kind, body) : mt) : CST.class_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_where (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LCURL_opt_cdecl_rep_SEMI_cdecl_opt_SEMI_RCURL (
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_cdecl (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.trans_token (Run.matcher_token v0),
                                                trans_cdecl (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v -> Run.trans_token (Run.matcher_token v))
                              v2
                            ,
                            Run.trans_token (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Layout_start_opt_cdecl_rep_choice_SEMI_cdecl_opt_choice_SEMI_layout_end (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_layout_start (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1; v2] ->
                                    (
                                      trans_cdecl (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                (match v0 with
                                                | Alt (0, v) ->
                                                    `SEMI (
                                                      Run.trans_token (Run.matcher_token v)
                                                    )
                                                | Alt (1, v) ->
                                                    `Layout_semi (
                                                      trans_layout_semicolon (Run.matcher_token v)
                                                    )
                                                | _ -> assert false
                                                )
                                                ,
                                                trans_cdecl (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Alt (0, v) ->
                                              `SEMI (
                                                Run.trans_token (Run.matcher_token v)
                                              )
                                          | Alt (1, v) ->
                                              `Layout_semi (
                                                trans_layout_semicolon (Run.matcher_token v)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v2
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            trans_layout_end (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_adt_rhs ((kind, body) : mt) : CST.adt_rhs =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_constructors (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_deriving (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_gadt_rhs ((kind, body) : mt) : CST.gadt_rhs =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_where (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LCURL_opt_choice_gadt_cons_rep_SEMI_choice_gadt_cons_opt_SEMI_RCURL (
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      (match v0 with
                                      | Alt (0, v) ->
                                          `Gadt_cons (
                                            trans_gadt_constructor (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Deri (
                                            trans_deriving (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                      ,
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.trans_token (Run.matcher_token v0),
                                                (match v1 with
                                                | Alt (0, v) ->
                                                    `Gadt_cons (
                                                      trans_gadt_constructor (Run.matcher_token v)
                                                    )
                                                | Alt (1, v) ->
                                                    `Deri (
                                                      trans_deriving (Run.matcher_token v)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v -> Run.trans_token (Run.matcher_token v))
                              v2
                            ,
                            Run.trans_token (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Layout_start_opt_choice_gadt_cons_rep_choice_SEMI_choice_gadt_cons_opt_choice_SEMI_layout_end (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_layout_start (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1; v2] ->
                                    (
                                      (match v0 with
                                      | Alt (0, v) ->
                                          `Gadt_cons (
                                            trans_gadt_constructor (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Deri (
                                            trans_deriving (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                      ,
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                (match v0 with
                                                | Alt (0, v) ->
                                                    `SEMI (
                                                      Run.trans_token (Run.matcher_token v)
                                                    )
                                                | Alt (1, v) ->
                                                    `Layout_semi (
                                                      trans_layout_semicolon (Run.matcher_token v)
                                                    )
                                                | _ -> assert false
                                                )
                                                ,
                                                (match v1 with
                                                | Alt (0, v) ->
                                                    `Gadt_cons (
                                                      trans_gadt_constructor (Run.matcher_token v)
                                                    )
                                                | Alt (1, v) ->
                                                    `Deri (
                                                      trans_deriving (Run.matcher_token v)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Alt (0, v) ->
                                              `SEMI (
                                                Run.trans_token (Run.matcher_token v)
                                              )
                                          | Alt (1, v) ->
                                              `Layout_semi (
                                                trans_layout_semicolon (Run.matcher_token v)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v2
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            trans_layout_end (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_class ((kind, body) : mt) : CST.decl_class =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_context_ (Run.matcher_token v))
              v1
            ,
            trans_constraint_ (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_fundeps (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_class_body (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_adt ((kind, body) : mt) : CST.adt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Adt_rhs (
                  trans_adt_rhs (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Gadt_rhs (
                  trans_gadt_rhs (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_newtype ((kind, body) : mt) : CST.decl_newtype =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_context_newtype (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Newt (
                  trans_newtype (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Opt_type_anno_gadt_rhs (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v -> trans_type_annotation (Run.matcher_token v))
                          v0
                        ,
                        trans_gadt_rhs (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_adt ((kind, body) : mt) : CST.decl_adt =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_context_ (Run.matcher_token v))
              v1
            ,
            trans_simpletype (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_annotation (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Adt (
                      trans_adt (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Rep_deri (
                      Run.repeat
                        (fun v -> trans_deriving (Run.matcher_token v))
                        v
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_inst_datainst ((kind, body) : mt) : CST.inst_datainst =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Data_opt_inst_data_opt_adt (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                  ,
                  trans_datainst (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_adt (Run.matcher_token v))
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Newt_opt_inst_data_newt (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                  ,
                  trans_datainst (Run.matcher_token v2),
                  trans_newtype (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_datainst ((kind, body) : mt) : CST.decl_datainst =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Data_inst_data_opt_adt (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_datainst (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_adt (Run.matcher_token v))
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Newt_inst_data_newt (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_datainst (Run.matcher_token v2),
                  trans_newtype (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_idecl ((kind, body) : mt) : CST.idecl =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func (
            trans_function_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Sign (
            trans_signature (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inst_data (
            trans_inst_datainst (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Inst_tyinst (
            trans_inst_tyinst (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_decl_instance ((kind, body) : mt) : CST.decl_instance =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_instance (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_where (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Alt (0, v) ->
                              `LCURL_opt_idecl_rep_SEMI_idecl_opt_SEMI_RCURL (
                                (match v with
                                | Seq [v0; v1; v2; v3] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                trans_idecl (Run.matcher_token v0),
                                                Run.repeat
                                                  (fun v ->
                                                    (match v with
                                                    | Seq [v0; v1] ->
                                                        (
                                                          Run.trans_token (Run.matcher_token v0),
                                                          trans_idecl (Run.matcher_token v1)
                                                        )
                                                    | _ -> assert false
                                                    )
                                                  )
                                                  v1
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      Run.opt
                                        (fun v -> Run.trans_token (Run.matcher_token v))
                                        v2
                                      ,
                                      Run.trans_token (Run.matcher_token v3)
                                    )
                                | _ -> assert false
                                )
                              )
                          | Alt (1, v) ->
                              `Layout_start_opt_idecl_rep_choice_SEMI_idecl_opt_choice_SEMI_layout_end (
                                (match v with
                                | Seq [v0; v1; v2] ->
                                    (
                                      trans_layout_start (Run.matcher_token v0),
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1; v2] ->
                                              (
                                                trans_idecl (Run.matcher_token v0),
                                                Run.repeat
                                                  (fun v ->
                                                    (match v with
                                                    | Seq [v0; v1] ->
                                                        (
                                                          (match v0 with
                                                          | Alt (0, v) ->
                                                              `SEMI (
                                                                Run.trans_token (Run.matcher_token v)
                                                              )
                                                          | Alt (1, v) ->
                                                              `Layout_semi (
                                                                trans_layout_semicolon (Run.matcher_token v)
                                                              )
                                                          | _ -> assert false
                                                          )
                                                          ,
                                                          trans_idecl (Run.matcher_token v1)
                                                        )
                                                    | _ -> assert false
                                                    )
                                                  )
                                                  v1
                                                ,
                                                Run.opt
                                                  (fun v ->
                                                    (match v with
                                                    | Alt (0, v) ->
                                                        `SEMI (
                                                          Run.trans_token (Run.matcher_token v)
                                                        )
                                                    | Alt (1, v) ->
                                                        `Layout_semi (
                                                          trans_layout_semicolon (Run.matcher_token v)
                                                        )
                                                    | _ -> assert false
                                                    )
                                                  )
                                                  v2
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      trans_layout_end (Run.matcher_token v2)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_topdecl ((kind, body) : mt) : CST.topdecl =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Decl_type (
            trans_decl_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Decl_tyfam (
            trans_decl_tyfam (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Decl_tyinst (
            trans_decl_tyinst (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Decl_role (
            trans_decl_role (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Decl_adt (
            trans_decl_adt (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Decl_newt (
            trans_decl_newtype (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Decl_data_8db362d (
            trans_decl_datafam (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Decl_data_2e645bc (
            trans_decl_datainst (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Decl_import (
            trans_decl_import (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Decl_class (
            trans_decl_class (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Decl_inst (
            trans_decl_instance (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Decl_defa (
            trans_decl_default (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Decl_fore (
            trans_decl_foreign (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Decl_deri (
            trans_decl_deriving (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Decl (
            trans_decl (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Decl_pat (
            trans_decl_pattern (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Top_splice (
            trans_top_splice (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_ ((kind, body) : mt) : CST.module_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_qmodid (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_exports (Run.matcher_token v))
              v2
            ,
            trans_where (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LCURL_opt_topd_rep_SEMI_topd_opt_SEMI_RCURL (
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      trans_topdecl (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                Run.trans_token (Run.matcher_token v0),
                                                trans_topdecl (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v -> Run.trans_token (Run.matcher_token v))
                              v2
                            ,
                            Run.trans_token (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Layout_start_opt_topd_rep_choice_SEMI_topd_opt_choice_SEMI_layout_end (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_layout_start (Run.matcher_token v0),
                            Run.opt
                              (fun v ->
                                (match v with
                                | Seq [v0; v1; v2] ->
                                    (
                                      trans_topdecl (Run.matcher_token v0),
                                      Run.repeat
                                        (fun v ->
                                          (match v with
                                          | Seq [v0; v1] ->
                                              (
                                                (match v0 with
                                                | Alt (0, v) ->
                                                    `SEMI (
                                                      Run.trans_token (Run.matcher_token v)
                                                    )
                                                | Alt (1, v) ->
                                                    `Layout_semi (
                                                      trans_layout_semicolon (Run.matcher_token v)
                                                    )
                                                | _ -> assert false
                                                )
                                                ,
                                                trans_topdecl (Run.matcher_token v1)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v1
                                      ,
                                      Run.opt
                                        (fun v ->
                                          (match v with
                                          | Alt (0, v) ->
                                              `SEMI (
                                                Run.trans_token (Run.matcher_token v)
                                              )
                                          | Alt (1, v) ->
                                              `Layout_semi (
                                                trans_layout_semicolon (Run.matcher_token v)
                                              )
                                          | _ -> assert false
                                          )
                                        )
                                        v2
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            trans_layout_end (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_haskell ((kind, body) : mt) : CST.haskell =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Empty_file (
            trans_empty_file (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Module (
            trans_module_ (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Topd_rep_choice_SEMI_topd_opt_choice_SEMI (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_topdecl (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            (match v0 with
                            | Alt (0, v) ->
                                `SEMI (
                                  Run.trans_token (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Layout_semi (
                                  trans_layout_semicolon (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                            ,
                            trans_topdecl (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `SEMI (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Layout_semi (
                            trans_layout_semicolon (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_haskell matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

