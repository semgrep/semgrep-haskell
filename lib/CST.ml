(* Generated by ocaml-tree-sitter. *)
(*
   haskell grammar

   entrypoint: haskell
*)

open! Sexplib.Conv
open Tree_sitter_run

type comma = Token.t

type namespace = [
    `Pat of Token.t (* "pattern" *)
  | `Type of Token.t (* "type" *)
]

type where = Token.t

type type_role = [
    `Repr of Token.t (* "representational" *)
  | `Nomi of Token.t (* "nominal" *)
  | `Phan of Token.t (* "phantom" *)
  | `X__ of Token.t (* "_" *)
]

type do_keyword = [ `Mdo of Token.t (* "mdo" *) | `Do of Token.t (* "do" *) ]

type layout_start = Token.t

type splice_dollar = Token.t

type quasiquote_start = Token.t

type arrow = [
    `UNKUNKUNK of Token.t (* "\226\134\146" *)
  | `DASHGT of Token.t (* "->" *)
]

type integer_literal = Token.t

type con_unit = (Token.t (* "(" *) * Token.t (* ")" *))

type forall_kw = [
    `Forall of Token.t (* "forall" *)
  | `UNKUNKUNK of Token.t (* "\226\136\128" *)
]

type conid = Token.t (* pattern "[\\p{Lu}\\p{Lt}](\\w|')*#?" *)

type con_list = (Token.t (* "[" *) * Token.t (* "]" *))

type type_star = [
    `STAR of Token.t (* "*" *)
  | `UNKUNKUNK of Token.t (* "\226\152\133" *)
]

type imm_tok_at = Token.t (* "@" *)

type layout_semicolon = Token.t

type larrow = [
    `UNKUNKUNK of Token.t (* "\226\134\144" *)
  | `LTDASH of Token.t (* "<-" *)
]

type carrow = [
    `UNKUNKUNK of Token.t (* "\226\135\146" *)
  | `EQGT of Token.t (* "=>" *)
]

type binary_literal = Token.t

type char = Token.t

type unboxed_close = Token.t

type colon2 = [
    `UNKUNKUNK of Token.t (* "\226\136\183" *)
  | `COLONCOLON of Token.t (* "::" *)
]

type float_ = Token.t

type deriving_strategy = [
    `Stock of Token.t (* "stock" *)
  | `Newt of Token.t (* "newtype" *)
  | `Anyc of Token.t (* "anyclass" *)
]

type unboxed_open = [
    `LPARHASHSPACE of Token.t (* "(# " *)
  | `LPARHASHLF of Token.t (* "(#\n" *)
]

type quasiquote_bar = Token.t

type empty_file = Token.t

type safety = [
    `Unsafe of Token.t (* "unsafe" *)
  | `Safe of Token.t (* "safe" *)
  | `Inte of Token.t (* "interruptible" *)
]

type varid = Token.t (* pattern "[_\\p{Ll}](\\w|')*#?" *)

type quasiquote_body = Token.t

type implicit_parid = Token.t (* pattern "\\?[_\\p{Ll}](\\w|')*" *)

type dot = Token.t

type string_ = Token.t

type octal_literal = Token.t

type strict = Token.t

type label = Token.t (* pattern "#[_\\p{Ll}](\\w|')*" *)

type semgrep_metavariable = Token.t

type layout_end = Token.t

type tok_barrbrack = Token.t

type varsym = Token.t

type calling_convention = [
    `Ccall of Token.t (* "ccall" *)
  | `Stdc of Token.t (* "stdcall" *)
  | `Cpluss of Token.t (* "cplusplus" *)
  | `Jvm of Token.t (* "jvm" *)
  | `Dotnet of Token.t (* "dotnet" *)
  | `Prim of Token.t (* "prim" *)
  | `Capi of Token.t (* "capi" *)
]

type hex_literal = Token.t

type consym = Token.t

type tyconsym = Token.t

type con_tuple = (
    Token.t (* "(" *)
  * comma (*tok*) list (* one or more *)
  * Token.t (* ")" *)
)

type forall_dot = [ `DOT of Token.t (* "." *) | `Arrow of arrow ]

type anon_choice_SEMI_ab17175 = [
    `SEMI of Token.t (* ";" *)
  | `Layout_semi of layout_semicolon (*tok*)
]

type constructor = [
    `Conid of conid (*tok*)
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type foreign_pre = (calling_convention * safety option)

type integer = [
    `Bin_lit of binary_literal (*tok*)
  | `Int_lit of integer_literal (*tok*)
  | `Octal_lit of octal_literal (*tok*)
  | `Hex_lit of hex_literal (*tok*)
]

type gcon_literal = [
    `Con_unit of con_unit
  | `Con_list of con_list
  | `Con_tuple of con_tuple
]

type tyfam_injectivity = (
    Token.t (* "|" *)
  * varid (*tok*)
  * arrow
  * varid (*tok*) list (* one or more *)
)

type variable = [
    `Varid of varid (*tok*)
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type fundep = (
    varid (*tok*) list (* one or more *)
  * arrow
  * varid (*tok*) list (* one or more *)
)

type stringly = [ `Str of string_ (*tok*) | `Char of char (*tok*) ]

type modid = constructor

type tyconid = constructor

type operator_minus = [ `Op of varsym (*tok*) | `Minus of Token.t (* "-" *) ]

type number = [ `Int of integer | `Float of float_ (*tok*) ]

type type_operator = [
    `Tyco of tyconsym (*tok*)
  | `Cons_op of consym (*tok*)
]

type fundeps = (
    Token.t (* "|" *)
  * fundep
  * (comma (*tok*) * fundep) list (* zero or more *)
)

type qualifying_module = (modid * dot (*tok*)) list (* one or more *)

type ticked_tycon = (Token.t (* "`" *) * tyconid * Token.t (* "`" *))

type con = [
    `Cons of tyconid
  | `LPAR_cons_op_RPAR of (
        Token.t (* "(" *) * consym (*tok*) * Token.t (* ")" *)
    )
]

type varop = [
    `Choice_op of operator_minus
  | `BQUOT_var_BQUOT of (Token.t (* "`" *) * variable * Token.t (* "`" *))
]

type pat_name = [
    `Var of variable
  | `LPAR_choice_op_RPAR of (
        Token.t (* "(" *) * operator_minus * Token.t (* ")" *)
    )
]

type literal = [ `Choice_str of stringly | `Choice_int of number ]

type simple_tycon = [
    `Cons of tyconid
  | `LPAR_type_op_RPAR of (
        Token.t (* "(" *) * type_operator * Token.t (* ")" *)
    )
]

type qualified_constructor_operator = (qualifying_module * consym (*tok*))

type do_module = (qualifying_module * do_keyword)

type qualified_operator = (qualifying_module * operator_minus)

type conop = [
    `Cons_op of consym (*tok*)
  | `BQUOT_cons_BQUOT of ticked_tycon
]

type simple_tyconop = [
    `Ticked_tycon of ticked_tycon
  | `Type_op of type_operator
]

type name = [ `Choice_var of pat_name | `Choice_cons of con ]

type import_name = [ `Choice_cons of con | `Choice_var of pat_name ]

type fun_name = [
    `Choice_var of pat_name
  | `Impl_parid of implicit_parid (*tok*)
]

type literal_ = [ `Lit of literal | `Choice_con_unit of gcon_literal ]

type type_literal = [
    `Lit of literal
  | `Con_unit of con_unit
  | `Con_list of con_list
  | `Con_tuple of con_tuple
]

type qmodid = [
    `Qual_module of (qualifying_module * modid)
  | `Modid of modid
]

type qconsym = [
    `Qual_cons_op of qualified_constructor_operator
  | `Cons_op of consym (*tok*)
]

type qvarid = [
    `Qual_var of (qualifying_module * variable)
  | `Var of variable
]

type qtyconid = [
    `Qual_type of (qualifying_module * tyconid)
  | `Cons of tyconid
]

type qvarsym = [
    `Qual_op of qualified_operator
  | `Choice_op of operator_minus
]

type qvarsym_nominus = [
    `Qual_op of qualified_operator
  | `Op of varsym (*tok*)
]

type qualified_type_operator_ = [
    `Qual_type_op of (qualifying_module * tyconsym (*tok*))
  | `Qual_cons_op of qualified_constructor_operator
]

type qconid = [
    `Qual_cons of (qualifying_module * tyconid)
  | `Cons of tyconid
]

type op = [ `Varop of varop | `Choice_cons_op of conop ]

type export_names = (
    Token.t (* "(" *)
  * [
        `DOTDOT of Token.t (* ".." *)
      | `Opt_name_rep_comma_name of
          (name * (comma (*tok*) * name) list (* zero or more *)) option
    ]
      option
  * Token.t (* ")" *)
)

type import_con_names = (
    Token.t (* "(" *)
  * [
        `DOTDOT of Token.t (* ".." *)
      | `Import_name_rep_comma_import_name of (
            import_name
          * (comma (*tok*) * import_name) list (* zero or more *)
        )
    ]
      option
  * Token.t (* ")" *)
)

type quasiquote = (
    [
        `UNKUNKUNK of Token.t (* "\226\159\166" *)
      | `Quas_start_opt_choice_qual_var_quas_bar of (
            quasiquote_start (*tok*)
          * qvarid option
          * quasiquote_bar (*tok*)
        )
    ]
  * quasiquote_body (*tok*) option
  * [
        `Tok_barr of tok_barrbrack (*tok*)
      | `UNKUNKUNK of Token.t (* "\226\159\167" *)
    ]
)

type qvarop = [
    `Choice_qual_op of qvarsym
  | `BQUOT_choice_qual_var_BQUOT of (
        Token.t (* "`" *) * qvarid * Token.t (* "`" *)
    )
]

type qvar = [
    `Choice_qual_var of qvarid
  | `LPAR_choice_qual_op_RPAR of (
        Token.t (* "(" *) * qvarsym * Token.t (* ")" *)
    )
]

type qvarop_nominus = [
    `Choice_qual_op of qvarsym_nominus
  | `BQUOT_choice_qual_var_BQUOT of (
        Token.t (* "`" *) * qvarid * Token.t (* "`" *)
    )
]

type qtyconsym = [
    `Qual_type_op_ of qualified_type_operator_
  | `Type_op of type_operator
]

type qconop = [
    `Choice_qual_cons_op of qconsym
  | `BQUOT_choice_qual_cons_BQUOT of (
        Token.t (* "`" *) * qconid * Token.t (* "`" *)
    )
]

type qcon = [
    `Choice_qual_cons of qconid
  | `LPAR_choice_qual_cons_op_RPAR of (
        Token.t (* "(" *) * qconsym * Token.t (* ")" *)
    )
]

type import_item = (
    namespace option
  * [
        `Choice_var of pat_name
      | `Choice_cons_opt_import_con_names of (
            simple_tycon
          * import_con_names option
        )
    ]
)

type qtycon = [
    `Choice_qual_type of qtyconid
  | `LPAR_choice_qual_type_op__RPAR of (
        Token.t (* "(" *) * qtyconsym * Token.t (* ")" *)
    )
]

type qtyconops = [
    `Ticked_qtycon of (Token.t (* "`" *) * qtyconid * Token.t (* "`" *))
  | `Choice_qual_type_op_ of qtyconsym
]

type qop_nominus = [
    `Qvarop_nominus of qvarop_nominus
  | `Choice_choice_qual_cons_op of qconop
]

type qop = [ `Qvarop of qvarop | `Choice_choice_qual_cons_op of qconop ]

type pat_constructor = qcon

type import_list = (
    Token.t (* "hiding" *) option
  * Token.t (* "(" *)
  * (
        import_item
      * (comma (*tok*) * import_item) list (* zero or more *)
      * comma (*tok*) option
    )
      option
  * Token.t (* ")" *)
)

type export = [
    `Choice_choice_qual_var of qvar
  | `Opt_name_choice_choice_qual_type_opt_export_names of (
        namespace option
      * qtycon
      * export_names option
    )
  | `Module_qmodid of (Token.t (* "module" *) * qmodid)
]

type qname = [ `Choice_choice_qual_var of qvar | `Qcon of pat_constructor ]

type exp_name = [
    `Choice_choice_qual_var of qvar
  | `Qcon of pat_constructor
  | `Impl_parid of implicit_parid (*tok*)
  | `Label of label (*tok*)
]

type exports = (
    Token.t (* "(" *)
  * (export * (comma (*tok*) * export) list (* zero or more *)) option
  * comma (*tok*) option
  * Token.t (* ")" *)
)

type gtycon = [
    `Prom_tycon of (Token.t (* "'" *) * qtycon)
  | `Choice_choice_qual_type of qtycon
  | `Tycon_arrow of (Token.t (* "(" *) * arrow * Token.t (* ")" *))
]

type qtyconop = [
    `Prom_tyco of (Token.t (* "'" *) * qtyconops)
  | `Qtycos of qtyconops
]

type aexp = [
    `Exp_name of exp_name
  | `Exp_parens of exp_parens
  | `Exp_tuple_ of (Token.t (* "(" *) * exp_tuple * Token.t (* ")" *))
  | `Exp_list of (
        Token.t (* "[" *)
      * exp
      * (comma (*tok*) * exp) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `Exp_th_quoted_name of exp_th_quoted_name
  | `Exp_type_app of (Token.t (* "@" *) * atype)
  | `Exp_lambda_case of (
        Token.t (* "\\" *)
      * Token.t (* "case" *)
      * alts option
    )
  | `Exp_do of (
        [ `Do_module of do_module | `Do_kw of do_keyword ]
      * anon_choice_LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL_9605efc
    )
  | `Exp_record of (
        aexp
      * Token.t (* "{" *)
      * exp_field
      * (comma (*tok*) * exp_field) list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Exp_arit_seq of (
        Token.t (* "[" *)
      * exp
      * (comma (*tok*) * exp) option
      * Token.t (* ".." *)
      * exp option
      * Token.t (* "]" *)
    )
  | `Exp_list_comp of (
        Token.t (* "[" *)
      * exp
      * Token.t (* "|" *)
      * qual
      * (comma (*tok*) * qual) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `Exp_sect_left of (
        Token.t (* "(" *) * top_splice * qop * Token.t (* ")" *)
    )
  | `Exp_sect_right of (
        Token.t (* "(" *) * qop_nominus * top_splice * Token.t (* ")" *)
    )
  | `Exp_unbo_tuple of (
        unboxed_open
      * (exp option * anon_rep_comma_opt_exp_fc8072d) option
      * unboxed_close (*tok*)
    )
  | `Exp_unbo_sum_ of (
        unboxed_open * exp_unboxed_sum * unboxed_close (*tok*)
    )
  | `Splice of splice
  | `Quas of quasiquote
  | `Lit_ of literal_
]

and alt = (pat * alt_variants * anon_opt_where_opt_decls_4a349ec)

and alt_variants = [
    `Arrow_exp of (arrow * exp)
  | `Rep1_gdpat of gdpat list (* one or more *)
]

and alts = [
    `LCURL_opt_alt_rep_SEMI_alt_opt_SEMI_RCURL of (
        Token.t (* "{" *)
      * (alt * (Token.t (* ";" *) * alt) list (* zero or more *)) option
      * Token.t (* ";" *) option
      * Token.t (* "}" *)
    )
  | `Layout_start_opt_alt_rep_choice_SEMI_alt_opt_choice_SEMI_layout_end of (
        layout_start (*tok*)
      * (
            alt
          * (anon_choice_SEMI_ab17175 * alt) list (* zero or more *)
          * anon_choice_SEMI_ab17175 option
        )
          option
      * layout_end (*tok*)
    )
]

and anon_LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL_2255345 = (
    Token.t (* "{" *)
  * anon_decl_rep_SEMI_decl_5323e44 option
  * Token.t (* ";" *) option
  * Token.t (* "}" *)
)

and anon_choice_LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL_9605efc = [
    `LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL of (
        Token.t (* "{" *)
      * anon_stmt_rep_SEMI_stmt_7a63907 option
      * Token.t (* ";" *) option
      * Token.t (* "}" *)
    )
  | `Layout_start_opt_stmt_rep_choice_SEMI_stmt_opt_choice_SEMI_layout_end of (
        layout_start (*tok*)
      * anon_stmt_rep_choice_SEMI_stmt_opt_choice_SEMI_a6f3eb1 option
      * layout_end (*tok*)
    )
]

and anon_choice_cons__a70bc96 = [
    `Cons_ of constraint__
  | `Impl_param of implicit_param
]

and anon_decl_rep_SEMI_decl_5323e44 = (
    decl
  * (Token.t (* ";" *) * decl) list (* zero or more *)
)

and anon_decl_rep_choice_SEMI_decl_opt_choice_SEMI_896561c = (
    decl
  * (anon_choice_SEMI_ab17175 * decl) list (* zero or more *)
  * anon_choice_SEMI_ab17175 option
)

and anon_opt_where_opt_decls_4a349ec = (where (*tok*) * decls option) option

and anon_rep_comma_opt_exp_fc8072d =
  (comma (*tok*) * exp option) list (* zero or more *)

and anon_stmt_rep_SEMI_stmt_7a63907 = (
    stmt
  * (Token.t (* ";" *) * stmt) list (* zero or more *)
)

and anon_stmt_rep_choice_SEMI_stmt_opt_choice_SEMI_a6f3eb1 = (
    stmt
  * (anon_choice_SEMI_ab17175 * stmt) list (* zero or more *)
  * anon_choice_SEMI_ab17175 option
)

and apat = [
    `Pat_name of pat_name
  | `Pat_as of (variable * imm_tok_at (*tok*) * apat)
  | `Pat_cons of pat_constructor
  | `Pat_record of (pat_constructor * pat_fields)
  | `Lit_ of literal_
  | `Pat_wild of Token.t (* "_" *)
  | `Pat_parens of (Token.t (* "(" *) * nested_pat * Token.t (* ")" *))
  | `Pat_tuple of (
        Token.t (* "(" *)
      * nested_pat
      * (comma (*tok*) * nested_pat) list (* one or more *)
      * Token.t (* ")" *)
    )
  | `Pat_unbo_tuple of (
        unboxed_open
      * (nested_pat * (comma (*tok*) * nested_pat) list (* zero or more *))
          option
      * unboxed_close (*tok*)
    )
  | `Pat_unbo_sum_ of (
        unboxed_open * pat_unboxed_sum * unboxed_close (*tok*)
    )
  | `Pat_list of (
        Token.t (* "[" *)
      * nested_pat
      * (comma (*tok*) * nested_pat) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `Pat_strict of (strict (*tok*) * apat)
  | `Pat_irre of (Token.t (* "~" *) * apat)
  | `Splice of splice
  | `Quas of quasiquote
]

and atype = [
    `Type_name of type_name
  | `Type_star of type_star
  | `Type_lit_ of type_literal_
  | `Type_parens of (
        Token.t (* "(" *) * type_or_implicit * Token.t (* ")" *)
    )
  | `Type_unbo_tuple of (
        unboxed_open
      * (
            type_or_implicit
          * (comma (*tok*) * type_or_implicit) list (* zero or more *)
        )
          option
      * unboxed_close (*tok*)
    )
  | `Type_unbo_sum of (unboxed_open * type_sum * unboxed_close (*tok*))
  | `Splice of splice
  | `Quas of quasiquote
]

and bind_pattern = (typed_pat * larrow * exp)

and btype = [
    `Atype of atype
  | `Type_apply of (atype * atype list (* one or more *))
]

and constraint_ = [
    `Type_name_rep_atype of (type_name * atype list (* zero or more *))
  | `Type_infix_ of type_infix_
]

and constraint__ = [
    `Quan_cons of (forall * forall_dot * constraint__)
  | `Cons_cont of (context_ * constraint__)
  | `LPAR_cons__RPAR of (
        Token.t (* "(" *) * constraint__ * Token.t (* ")" *)
    )
  | `Cons of constraint_
]

and context = (context_constraints * carrow)

and context_ = context

and context_constraints = [
    `Cons of constraint_
  | `LPAR_opt_choice_cons__rep_comma_choice_cons__RPAR of (
        Token.t (* "(" *)
      * (
            anon_choice_cons__a70bc96
          * (comma (*tok*) * anon_choice_cons__a70bc96)
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
]

and decl = [ `Gend of gendecl | `Decl_fun of decl_fun ]

and decl_fun = [ `Func of function_ | `Funpat of (typed_pat * funrhs) ]

and decls = [
    `LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL of
      anon_LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL_2255345
  | `Layout_start_opt_decl_rep_choice_SEMI_decl_opt_choice_SEMI_layout_end of (
        layout_start (*tok*)
      * anon_decl_rep_choice_SEMI_decl_opt_choice_SEMI_896561c option
      * layout_end (*tok*)
    )
]

and exp = (top_splice * type_annotation option)

and exp_apply = [
    `Aexp of aexp
  | `Aexp_exp_apply of (aexp * exp_apply)
  | `Aexp_exp_lambda of (aexp * exp_lambda)
  | `Aexp_exp_let_in of (aexp * exp_let_in)
  | `Aexp_exp_cond of (aexp * exp_cond)
  | `Aexp_exp_case of (aexp * exp_case)
]

and exp_case = (
    Token.t (* "case" *)
  * exp
  * Token.t (* "of" *)
  * alts option
)

and exp_cond = (
    Token.t (* "if" *)
  * exp
  * Token.t (* ";" *) option
  * Token.t (* "then" *)
  * exp
  * Token.t (* ";" *) option
  * Token.t (* "else" *)
  * exp
)

and exp_field = [
    `DOTDOT of Token.t (* ".." *)
  | `Choice_choice_qual_var_opt_EQ_exp of (
        qvar
      * (Token.t (* "=" *) * exp) option
    )
]

and exp_in = (Token.t (* "in" *) * exp)

and exp_infix = [ `Exp_infix_ of (top_splice * qop * lexp) | `Lexp of lexp ]

and exp_lambda = (Token.t (* "\\" *) * fun_patterns * arrow * exp)

and exp_let = (Token.t (* "let" *) * let_decls option)

and exp_let_in = (exp_let * exp_in)

and exp_parens = (Token.t (* "(" *) * exp * Token.t (* ")" *))

and exp_th_quoted_name = [
    `SQUOT_choice_choice_choice_qual_var of (Token.t (* "'" *) * qname)
  | `SQUOTSQUOT_atype of (Token.t (* "''" *) * atype)
]

and exp_tuple = (
    [
        `Rep1_comma_exp of (comma (*tok*) list (* one or more *) * exp)
      | `Exp_comma_opt_exp of (exp * comma (*tok*) * exp option)
    ]
  * anon_rep_comma_opt_exp_fc8072d
)

and exp_unboxed_sum = (
    exp option
  * (Token.t (* "|" *) * exp option) list (* one or more *)
)

and fexp = [ `Aexp of aexp | `Exp_apply of exp_apply ]

and forall = (forall_kw * tyvar list (* one or more *))

and fun_arrow = (modifier option * arrow)

and fun_guards = guard_equation list (* one or more *)

and fun_patterns = apat list (* one or more *)

and function_ = (funlhs * funrhs)

and funlhs = [
    `Funvar of (fun_name * fun_patterns option)
  | `Funpat_infix of (pat * varop * pat)
]

and funrhs = (
    [ `EQ_exp of (Token.t (* "=" *) * exp) | `Fun_guards of fun_guards ]
  * anon_opt_where_opt_decls_4a349ec
)

and gdpat = (guards * arrow * exp)

and gendecl = [
    `Sign of signature
  | `Fixity of (
        [
            `Infixl of Token.t (* "infixl" *)
          | `Infixr of Token.t (* "infixr" *)
          | `Infix of Token.t (* "infix" *)
        ]
      * integer option
      * op
      * (comma (*tok*) * op) list (* zero or more *)
    )
]

and guard = [
    `Pat_guard of (pat * larrow * top_splice)
  | `Let of let_
  | `Exp_infix of top_splice
]

and guard_equation = (guards * Token.t (* "=" *) * exp)

and guards = (
    Token.t (* "|" *)
  * guard
  * (comma (*tok*) * guard) list (* zero or more *)
)

and implicit_param = (implicit_parid (*tok*) * type_annotation)

and let_ = (Token.t (* "let" *) * decls option)

and let_decls = [
    `LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL of
      anon_LCURL_opt_decl_rep_SEMI_decl_opt_SEMI_RCURL_2255345
  | `Layout_start_opt_decl_rep_choice_SEMI_decl_opt_choice_SEMI of (
        layout_start (*tok*)
      * anon_decl_rep_choice_SEMI_decl_opt_choice_SEMI_896561c option
    )
]

and lexp = [
    `Exp_let_in of exp_let_in
  | `Exp_cond of exp_cond
  | `Exp_if_guard of (Token.t (* "if" *) * gdpat list (* one or more *))
  | `Exp_case of exp_case
  | `Exp_nega of (Token.t (* "-" *) * aexp)
  | `Fexp of fexp
  | `Exp_lambda of exp_lambda
]

and lpat = [
    `Apat of apat
  | `Pat_nega of (Token.t (* "-" *) * apat)
  | `Pat_apply of (pat_constructor * fun_patterns)
]

and modifier = (Token.t (* "%" *) * atype)

and nested_pat = [
    `Typed_pat of typed_pat
  | `Pat_view of (exp * arrow * nested_pat)
]

and pat = [ `Pat_infix of (lpat * qconop * pat) | `Lpat of lpat ]

and pat_field = [
    `DOTDOT of Token.t (* ".." *)
  | `Choice_choice_qual_var_opt_EQ_nested_pat of (
        qvar
      * (Token.t (* "=" *) * nested_pat) option
    )
]

and pat_fields = (
    Token.t (* "{" *)
  * (pat_field * (comma (*tok*) * pat_field) list (* zero or more *)) option
  * Token.t (* "}" *)
)

and pat_unboxed_sum = (
    nested_pat option
  * (Token.t (* "|" *) * nested_pat option) list (* one or more *)
)

and qual = [
    `Bind_pat of bind_pattern
  | `Let of let_
  | `Tran of transform
  | `Exp of exp
]

and signature = (
    pat_name
  * (comma (*tok*) * pat_name) list (* zero or more *)
  * type_annotation
)

and splice = (splice_dollar (*tok*) * splice_exp)

and splice_exp = [ `Exp_name of exp_name | `Exp_parens of exp_parens ]

and stmt = [
    `Exp of exp
  | `Bind_pat of bind_pattern
  | `Let of let_
  | `Rec of (
        Token.t (* "rec" *)
      * anon_choice_LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL_9605efc
    )
]

and top_splice = exp_infix

and transform = [
    `Then_exp_using_exp of (
        Token.t (* "then group by" *) * exp * Token.t (* "using" *) * exp
    )
  | `Then_exp_9b4d8a6 of (Token.t (* "then group using" *) * exp)
  | `Then_exp_8bf9922 of (Token.t (* "then" *) * exp)
]

and type_ = [
    `Type_quants of (forall * forall_dot * type_)
  | `Type_cont of (context_ * type_)
  | `Type_fun of (type_infix * fun_arrow * type_)
  | `Type_infix of type_infix
]

and type_annotation = (colon2 * type_or_implicit)

and type_infix = [ `Type_infix_ of type_infix_ | `Btype of btype ]

and type_infix_ = (btype * qtyconop * type_infix)

and type_literal_ = [
    `Type_prom_lit_c26b94c of (Token.t (* "'" *) * type_promotable_literal)
  | `Type_prom_lit_af79c83 of type_promotable_literal
]

and type_name = [
    `Choice_anno_type_var of tyvar
  | `Choice_prom_tycon of gtycon
]

and type_or_implicit = [ `Impl_param of implicit_param | `Type of type_ ]

and type_promotable_literal = [
    `Type_lit of type_literal
  | `Type_tuple_ of (Token.t (* "(" *) * type_tuple * Token.t (* ")" *))
  | `Type_list of (
        Token.t (* "[" *)
      * type_or_implicit
      * (comma (*tok*) * type_or_implicit) list (* zero or more *)
      * Token.t (* "]" *)
    )
]

and type_sum = (
    type_or_implicit
  * (Token.t (* "|" *) * type_or_implicit) list (* one or more *)
)

and type_tuple = (
    type_or_implicit
  * (comma (*tok*) * type_or_implicit) list (* one or more *)
)

and typed_pat = [ `Pat of pat | `Pat_typed of (pat * type_annotation) ]

and tyvar = [
    `Anno_type_var of (
        Token.t (* "(" *) * varid (*tok*) * type_annotation
      * Token.t (* ")" *)
    )
  | `Type_var of varid (*tok*)
]

type pattern_equals = (pat * Token.t (* "=" *) * pat)

type forall_ = (forall * forall_dot)

type pattern_type = (con * type_annotation)

type tyfam_result_type = (Token.t (* "=" *) * tyvar)

type via = (Token.t (* "via" *) * type_)

type strict_type = (strict (*tok*) * atype)

type pattern_decl = (pat * funrhs)

type inst_tyinst = (
    Token.t (* "type" *)
  * Token.t (* "instance" *) option
  * atype list (* zero or more *)
  * Token.t (* "=" *)
  * type_
)

type simpletype = [
    `LPAR_simp_RPAR of (Token.t (* "(" *) * tyfam_head * Token.t (* ")" *))
  | `Simp_infix of (tyvar * simple_tyconop * tyvar)
  | `Choice_cons_rep_choice_anno_type_var of (
        simple_tycon
      * tyvar list (* zero or more *)
    )
]

and tyfam_head = simpletype

type instance = (
    Token.t (* "instance" *)
  * forall_ option
  * context_ option
  * constraint_
)

type datainst = (
    forall_ option
  * context_ option
  * type_infix
  * type_annotation option
)

type tyfam_inj = (tyfam_result_type * tyfam_injectivity option)

type deriving = (
    Token.t (* "deriving" *)
  * deriving_strategy option
  * [
        `Choice_qual_type of qtyconid
      | `LPAR_opt_cons__rep_comma_cons__RPAR of (
            Token.t (* "(" *)
          * (
                constraint__
              * (comma (*tok*) * constraint__) list (* zero or more *)
            )
              option
          * Token.t (* ")" *)
        )
    ]
  * via option
)

type anon_choice_strict_type_5770e7f = [
    `Strict_type of strict_type
  | `Type_infix of type_infix
]

type field = (
    variable
  * (comma (*tok*) * variable) list (* zero or more *)
  * colon2
  * [ `Strict_type of strict_type | `Type of type_ ]
)

type pattern_arrow = (
    pat
  * larrow
  * pat
  * (
        where (*tok*)
      * [
            `LCURL_opt_pat_decl_rep_SEMI_pat_decl_opt_SEMI_RCURL of (
                Token.t (* "{" *)
              * (
                    pattern_decl
                  * (Token.t (* ";" *) * pattern_decl)
                      list (* zero or more *)
                )
                  option
              * Token.t (* ";" *) option
              * Token.t (* "}" *)
            )
          | `Layout_start_opt_pat_decl_rep_choice_SEMI_pat_decl_opt_choice_SEMI_layout_end of (
                layout_start (*tok*)
              * (
                    pattern_decl
                  * (anon_choice_SEMI_ab17175 * pattern_decl)
                      list (* zero or more *)
                  * anon_choice_SEMI_ab17175 option
                )
                  option
              * layout_end (*tok*)
            )
        ]
    )
      option
)

type tyfam_pat = [
    `Choice_qual_type_rep_atype of (qtyconid * atype list (* zero or more *))
  | `Btype_qtyc_btype of (btype * qtyconop * btype)
]

type decl_foreign = [
    `Decl_fore_import of (
        Token.t (* "foreign" *)
      * Token.t (* "import" *)
      * foreign_pre
      * string_ (*tok*) option
      * signature
    )
  | `Decl_fore_export of (
        Token.t (* "foreign" *)
      * Token.t (* "export" *)
      * foreign_pre
      * string_ (*tok*) option
      * signature
    )
]

type context_newtype = [
    `Cont__simp of (context_ * tyfam_head)
  | `Simp of tyfam_head
]

type gadt_sig = [
    `Gadt_fun of (anon_choice_strict_type_5770e7f * arrow * gadt_sig)
  | `Choice_strict_type of anon_choice_strict_type_5770e7f
]

type record_fields = (
    Token.t (* "{" *)
  * field
  * (comma (*tok*) * field) list (* zero or more *)
  * Token.t (* "}" *)
)

type record_field = (Token.t (* "{" *) * field * Token.t (* "}" *))

type tyfam_eq = (tyfam_pat * Token.t (* "=" *) * type_or_implicit)

type cdecl = [
    `Gend of gendecl
  | `Defa_sign of (Token.t (* "default" *) * signature)
  | `Func of function_
  | `Class_tyfam of (
        Token.t (* "type" *)
      * Token.t (* "family" *) option
      * tyfam_head
      * type_annotation option
    )
  | `Inst_tyinst of inst_tyinst
  | `Class_data of (
        Token.t (* "data" *)
      * Token.t (* "family" *) option
      * tyfam_head
      * type_annotation option
    )
]

type gadt_constr_type = (
    colon2
  * forall_ option
  * context_ option
  * [
        `Gadt_sig of gadt_sig
      | `Record_fields_arrow_gadt_sig of (record_fields * arrow * gadt_sig)
    ]
)

type newtype_constructor = (
    tyconid
  * [ `Atype of atype | `Record_field of record_field ]
)

type class_body = (
    where (*tok*)
  * [
        `LCURL_opt_cdecl_rep_SEMI_cdecl_opt_SEMI_RCURL of (
            Token.t (* "{" *)
          * (cdecl * (Token.t (* ";" *) * cdecl) list (* zero or more *))
              option
          * Token.t (* ";" *) option
          * Token.t (* "}" *)
        )
      | `Layout_start_opt_cdecl_rep_choice_SEMI_cdecl_opt_choice_SEMI_layout_end of (
            layout_start (*tok*)
          * (
                cdecl
              * (anon_choice_SEMI_ab17175 * cdecl) list (* zero or more *)
              * anon_choice_SEMI_ab17175 option
            )
              option
          * layout_end (*tok*)
        )
    ]
      option
)

type anon_choice_data_cons_3ed9ff3 = [
    `Data_cons of (
        tyconid
      * [ `Strict_type of strict_type | `Atype of atype ]
          list (* zero or more *)
    )
  | `Data_cons_infix of (
        anon_choice_strict_type_5770e7f * conop
      * anon_choice_strict_type_5770e7f
    )
  | `Data_cons_record of (tyconid * record_fields)
]

type newtype = (
    Token.t (* "=" *)
  * newtype_constructor
  * deriving list (* zero or more *)
)

type constructors = (
    forall_ option
  * context_ option
  * anon_choice_data_cons_3ed9ff3
  * (
        Token.t (* "|" *)
      * forall_ option
      * context_ option
      * anon_choice_data_cons_3ed9ff3
    )
      list (* zero or more *)
)

type anon_choice_gadt_cons_603dbe0 = [
    `Gadt_cons of (con * gadt_constr_type)
  | `Deri of deriving
]

type adt_rhs = (
    Token.t (* "=" *)
  * constructors
  * deriving list (* zero or more *)
)

type gadt_rhs = (
    where (*tok*)
  * [
        `LCURL_opt_choice_gadt_cons_rep_SEMI_choice_gadt_cons_opt_SEMI_RCURL of (
            Token.t (* "{" *)
          * (
                anon_choice_gadt_cons_603dbe0
              * (Token.t (* ";" *) * anon_choice_gadt_cons_603dbe0)
                  list (* zero or more *)
            )
              option
          * Token.t (* ";" *) option
          * Token.t (* "}" *)
        )
      | `Layout_start_opt_choice_gadt_cons_rep_choice_SEMI_choice_gadt_cons_opt_choice_SEMI_layout_end of (
            layout_start (*tok*)
          * (
                anon_choice_gadt_cons_603dbe0
              * (anon_choice_SEMI_ab17175 * anon_choice_gadt_cons_603dbe0)
                  list (* zero or more *)
              * anon_choice_SEMI_ab17175 option
            )
              option
          * layout_end (*tok*)
        )
    ]
      option
)

type adt = [ `Adt_rhs of adt_rhs | `Gadt_rhs of gadt_rhs ]

type inst_datainst = [
    `Data_opt_inst_data_opt_adt of (
        Token.t (* "data" *)
      * Token.t (* "instance" *) option
      * datainst
      * adt option
    )
  | `Newt_opt_inst_data_newt of (
        Token.t (* "newtype" *)
      * Token.t (* "instance" *) option
      * datainst
      * newtype
    )
]

type decl_datainst = [
    `Data_inst_data_opt_adt of (
        Token.t (* "data" *)
      * Token.t (* "instance" *)
      * datainst
      * adt option
    )
  | `Newt_inst_data_newt of (
        Token.t (* "newtype" *) * Token.t (* "instance" *) * datainst
      * newtype
    )
]

type idecl = [
    `Func of function_
  | `Sign of signature
  | `Inst_data of inst_datainst
  | `Inst_tyinst of inst_tyinst
]

type topdecl = [
    `Decl_type of (
        Token.t (* "type" *)
      * tyfam_head
      * [
            `EQ_type_or_impl of (Token.t (* "=" *) * type_or_implicit)
          | `Type_anno of type_annotation
        ]
    )
  | `Decl_tyfam of (
        Token.t (* "type" *)
      * Token.t (* "family" *)
      * tyfam_head
      * [ `Type_anno of type_annotation | `Tyfam_inj of tyfam_inj ] option
      * (
            where (*tok*)
          * [
                `LCURL_opt_tyfam_eq_rep_SEMI_tyfam_eq_opt_SEMI_RCURL of (
                    Token.t (* "{" *)
                  * (
                        tyfam_eq
                      * (Token.t (* ";" *) * tyfam_eq)
                          list (* zero or more *)
                    )
                      option
                  * Token.t (* ";" *) option
                  * Token.t (* "}" *)
                )
              | `Layout_start_opt_tyfam_eq_rep_choice_SEMI_tyfam_eq_opt_choice_SEMI_layout_end of (
                    layout_start (*tok*)
                  * (
                        tyfam_eq
                      * (anon_choice_SEMI_ab17175 * tyfam_eq)
                          list (* zero or more *)
                      * anon_choice_SEMI_ab17175 option
                    )
                      option
                  * layout_end (*tok*)
                )
            ]
              option
        )
          option
    )
  | `Decl_tyinst of (
        Token.t (* "type" *)
      * Token.t (* "instance" *)
      * atype list (* zero or more *)
      * Token.t (* "=" *)
      * type_or_implicit
    )
  | `Decl_role of (
        Token.t (* "type" *)
      * Token.t (* "role" *)
      * qtycon
      * type_role list (* one or more *)
    )
  | `Decl_adt of (
        Token.t (* "data" *)
      * context_ option
      * tyfam_head
      * type_annotation option
      * [ `Adt of adt | `Rep_deri of deriving list (* zero or more *) ]
          option
    )
  | `Decl_newt of (
        Token.t (* "newtype" *)
      * context_newtype
      * [
            `Newt of newtype
          | `Opt_type_anno_gadt_rhs of (type_annotation option * gadt_rhs)
        ]
    )
  | `Decl_data_8db362d of (
        Token.t (* "data" *)
      * Token.t (* "family" *)
      * tyfam_head
      * type_annotation option
    )
  | `Decl_data_2e645bc of decl_datainst
  | `Decl_import of (
        Token.t (* "import" *)
      * Token.t (* "qualified" *) option
      * string_ (*tok*) option
      * qmodid
      * Token.t (* "qualified" *) option
      * (Token.t (* "as" *) * qmodid) option
      * import_list option
    )
  | `Decl_class of (
        Token.t (* "class" *)
      * context_ option
      * constraint_
      * fundeps option
      * class_body option
    )
  | `Decl_inst of (
        instance
      * (
            where (*tok*)
          * [
                `LCURL_opt_idecl_rep_SEMI_idecl_opt_SEMI_RCURL of (
                    Token.t (* "{" *)
                  * (
                        idecl
                      * (Token.t (* ";" *) * idecl) list (* zero or more *)
                    )
                      option
                  * Token.t (* ";" *) option
                  * Token.t (* "}" *)
                )
              | `Layout_start_opt_idecl_rep_choice_SEMI_idecl_opt_choice_SEMI_layout_end of (
                    layout_start (*tok*)
                  * (
                        idecl
                      * (anon_choice_SEMI_ab17175 * idecl)
                          list (* zero or more *)
                      * anon_choice_SEMI_ab17175 option
                    )
                      option
                  * layout_end (*tok*)
                )
            ]
              option
        )
          option
    )
  | `Decl_defa of (
        Token.t (* "default" *)
      * Token.t (* "(" *)
      * (type_infix * (comma (*tok*) * type_infix) list (* zero or more *))
          option
      * Token.t (* ")" *)
    )
  | `Decl_fore of decl_foreign
  | `Decl_deri of (
        Token.t (* "deriving" *)
      * [ `Deri_stra of deriving_strategy | `Via of via ] option
      * instance
    )
  | `Decl of decl
  | `Decl_pat of (
        Token.t (* "pattern" *)
      * [
            `Pat_type of pattern_type
          | `Pat_equals of pattern_equals
          | `Pat_arrow of pattern_arrow
        ]
    )
  | `Top_splice of top_splice
]

type anon_topd_rep_choice_SEMI_topd_opt_choice_SEMI_eb02f02 = (
    topdecl
  * (anon_choice_SEMI_ab17175 * topdecl) list (* zero or more *)
  * anon_choice_SEMI_ab17175 option
)

type haskell = [
    `Empty_file of empty_file (*tok*)
  | `Module of (
        Token.t (* "module" *)
      * qmodid
      * exports option
      * where (*tok*)
      * [
            `LCURL_opt_topd_rep_SEMI_topd_opt_SEMI_RCURL of (
                Token.t (* "{" *)
              * (
                    topdecl
                  * (Token.t (* ";" *) * topdecl) list (* zero or more *)
                )
                  option
              * Token.t (* ";" *) option
              * Token.t (* "}" *)
            )
          | `Layout_start_opt_topd_rep_choice_SEMI_topd_opt_choice_SEMI_layout_end of (
                layout_start (*tok*)
              * anon_topd_rep_choice_SEMI_topd_opt_choice_SEMI_eb02f02 option
              * layout_end (*tok*)
            )
        ]
          option
    )
  | `Topd_rep_choice_SEMI_topd_opt_choice_SEMI of
      anon_topd_rep_choice_SEMI_topd_opt_choice_SEMI_eb02f02
]

type minus (* inlined *) = Token.t (* "-" *)

type cpp (* inlined *) = Token.t

type pat_wildcard (* inlined *) = Token.t (* "_" *)

type comment (* inlined *) = Token.t

type pragma (* inlined *) = Token.t

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type tycon_arrow (* inlined *) = (
    Token.t (* "(" *) * arrow * Token.t (* ")" *)
)

type type_variable (* inlined *) = varid (*tok*)

type expent (* inlined *) = string_ (*tok*)

type impent (* inlined *) = string_ (*tok*)

type operator (* inlined *) = varsym (*tok*)

type constructor_operator (* inlined *) = consym (*tok*)

type var (* inlined *) = [
    `Var of variable
  | `LPAR_choice_op_RPAR of (
        Token.t (* "(" *) * operator_minus * Token.t (* ")" *)
    )
]

type qualified_module (* inlined *) = (qualifying_module * modid)

type qualified_variable (* inlined *) = (qualifying_module * variable)

type qualified_type (* inlined *) = (qualifying_module * tyconid)

type qualified_type_operator (* inlined *) = (
    qualifying_module * tyconsym (*tok*)
)

type qualified_constructor (* inlined *) = (qualifying_module * tyconid)

type ticked_qtycon (* inlined *) = (
    Token.t (* "`" *) * qtyconid * Token.t (* "`" *)
)

type fixity (* inlined *) = (
    [
        `Infixl of Token.t (* "infixl" *)
      | `Infixr of Token.t (* "infixr" *)
      | `Infix of Token.t (* "infix" *)
    ]
  * integer option
  * op
  * (comma (*tok*) * op) list (* zero or more *)
)

type decl_role (* inlined *) = (
    Token.t (* "type" *)
  * Token.t (* "role" *)
  * qtycon
  * type_role list (* one or more *)
)

type promoted_tycon (* inlined *) = (Token.t (* "'" *) * qtycon)

type promoted_tyconop (* inlined *) = (Token.t (* "'" *) * qtyconops)

type gcon (* inlined *) = [
    `Qcon of pat_constructor
  | `Choice_con_unit of gcon_literal
]

type decl_import (* inlined *) = (
    Token.t (* "import" *)
  * Token.t (* "qualified" *) option
  * string_ (*tok*) option
  * qmodid
  * Token.t (* "qualified" *) option
  * (Token.t (* "as" *) * qmodid) option
  * import_list option
)

type annotated_type_variable (* inlined *) = (
    Token.t (* "(" *) * varid (*tok*) * type_annotation * Token.t (* ")" *)
)

type anon_LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL_13d08db (* inlined *) = (
    Token.t (* "{" *)
  * anon_stmt_rep_SEMI_stmt_7a63907 option
  * Token.t (* ";" *) option
  * Token.t (* "}" *)
)

type constraint_context (* inlined *) = (context_ * constraint__)

type exp_arithmetic_sequence (* inlined *) = (
    Token.t (* "[" *)
  * exp
  * (comma (*tok*) * exp) option
  * Token.t (* ".." *)
  * exp option
  * Token.t (* "]" *)
)

type exp_do (* inlined *) = (
    [ `Do_module of do_module | `Do_kw of do_keyword ]
  * anon_choice_LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL_9605efc
)

type exp_if_guard (* inlined *) = (
    Token.t (* "if" *)
  * gdpat list (* one or more *)
)

type exp_infix_ (* inlined *) = (top_splice * qop * lexp)

type exp_lambda_case (* inlined *) = (
    Token.t (* "\\" *)
  * Token.t (* "case" *)
  * alts option
)

type exp_list (* inlined *) = (
    Token.t (* "[" *)
  * exp
  * (comma (*tok*) * exp) list (* zero or more *)
  * Token.t (* "]" *)
)

type exp_list_comprehension (* inlined *) = (
    Token.t (* "[" *)
  * exp
  * Token.t (* "|" *)
  * qual
  * (comma (*tok*) * qual) list (* zero or more *)
  * Token.t (* "]" *)
)

type exp_negation (* inlined *) = (Token.t (* "-" *) * aexp)

type exp_record (* inlined *) = (
    aexp
  * Token.t (* "{" *)
  * exp_field
  * (comma (*tok*) * exp_field) list (* zero or more *)
  * Token.t (* "}" *)
)

type exp_section_left (* inlined *) = (
    Token.t (* "(" *) * top_splice * qop * Token.t (* ")" *)
)

type exp_section_right (* inlined *) = (
    Token.t (* "(" *) * qop_nominus * top_splice * Token.t (* ")" *)
)

type exp_tuple_ (* inlined *) = (
    Token.t (* "(" *) * exp_tuple * Token.t (* ")" *)
)

type exp_type_application (* inlined *) = (Token.t (* "@" *) * atype)

type exp_unboxed_sum_ (* inlined *) = (
    unboxed_open * exp_unboxed_sum * unboxed_close (*tok*)
)

type exp_unboxed_tuple (* inlined *) = (
    unboxed_open
  * (exp option * anon_rep_comma_opt_exp_fc8072d) option
  * unboxed_close (*tok*)
)

type funpat (* inlined *) = (typed_pat * funrhs)

type funpat_infix (* inlined *) = (pat * varop * pat)

type funvar (* inlined *) = (fun_name * fun_patterns option)

type pat_apply (* inlined *) = (pat_constructor * fun_patterns)

type pat_as (* inlined *) = (variable * imm_tok_at (*tok*) * apat)

type pat_infix (* inlined *) = (lpat * qconop * pat)

type pat_irrefutable (* inlined *) = (Token.t (* "~" *) * apat)

type pat_list (* inlined *) = (
    Token.t (* "[" *)
  * nested_pat
  * (comma (*tok*) * nested_pat) list (* zero or more *)
  * Token.t (* "]" *)
)

type pat_negation (* inlined *) = (Token.t (* "-" *) * apat)

type pat_parens (* inlined *) = (
    Token.t (* "(" *) * nested_pat * Token.t (* ")" *)
)

type pat_record (* inlined *) = (pat_constructor * pat_fields)

type pat_strict (* inlined *) = (strict (*tok*) * apat)

type pat_tuple (* inlined *) = (
    Token.t (* "(" *)
  * nested_pat
  * (comma (*tok*) * nested_pat) list (* one or more *)
  * Token.t (* ")" *)
)

type pat_typed (* inlined *) = (pat * type_annotation)

type pat_unboxed_sum_ (* inlined *) = (
    unboxed_open * pat_unboxed_sum * unboxed_close (*tok*)
)

type pat_unboxed_tuple (* inlined *) = (
    unboxed_open
  * (nested_pat * (comma (*tok*) * nested_pat) list (* zero or more *))
      option
  * unboxed_close (*tok*)
)

type pat_view (* inlined *) = (exp * arrow * nested_pat)

type pattern_guard (* inlined *) = (pat * larrow * top_splice)

type quantified_constraint (* inlined *) = (
    forall * forall_dot * constraint__
)

type rec_ (* inlined *) = (
    Token.t (* "rec" *)
  * anon_choice_LCURL_opt_stmt_rep_SEMI_stmt_opt_SEMI_RCURL_9605efc
)

type type_apply (* inlined *) = (atype * atype list (* one or more *))

type type_context (* inlined *) = (context_ * type_)

type type_fun (* inlined *) = (type_infix * fun_arrow * type_)

type type_list (* inlined *) = (
    Token.t (* "[" *)
  * type_or_implicit
  * (comma (*tok*) * type_or_implicit) list (* zero or more *)
  * Token.t (* "]" *)
)

type type_parens (* inlined *) = (
    Token.t (* "(" *) * type_or_implicit * Token.t (* ")" *)
)

type type_promoted_literal (* inlined *) = (
    Token.t (* "'" *) * type_promotable_literal
)

type type_quantifiers (* inlined *) = (forall * forall_dot * type_)

type type_tuple_ (* inlined *) = (
    Token.t (* "(" *) * type_tuple * Token.t (* ")" *)
)

type type_unboxed_sum (* inlined *) = (
    unboxed_open * type_sum * unboxed_close (*tok*)
)

type type_unboxed_tuple (* inlined *) = (
    unboxed_open
  * (
        type_or_implicit
      * (comma (*tok*) * type_or_implicit) list (* zero or more *)
    )
      option
  * unboxed_close (*tok*)
)

type tyfam_pat_prefix (* inlined *) = (
    qtyconid
  * atype list (* zero or more *)
)

type simpletype_infix (* inlined *) = (tyvar * simple_tyconop * tyvar)

type decl_tyinst (* inlined *) = (
    Token.t (* "type" *)
  * Token.t (* "instance" *)
  * atype list (* zero or more *)
  * Token.t (* "=" *)
  * type_or_implicit
)

type decl_default (* inlined *) = (
    Token.t (* "default" *)
  * Token.t (* "(" *)
  * (type_infix * (comma (*tok*) * type_infix) list (* zero or more *))
      option
  * Token.t (* ")" *)
)

type default_signature (* inlined *) = (Token.t (* "default" *) * signature)

type quantifiers (* inlined *) = (forall * forall_dot)

type decl_foreign_import (* inlined *) = (
    Token.t (* "foreign" *)
  * Token.t (* "import" *)
  * foreign_pre
  * string_ (*tok*) option
  * signature
)

type tyfam_pat_infix (* inlined *) = (btype * qtyconop * btype)

type decl_foreign_export (* inlined *) = (
    Token.t (* "foreign" *)
  * Token.t (* "export" *)
  * foreign_pre
  * string_ (*tok*) option
  * signature
)

type data_constructor (* inlined *) = (
    tyconid
  * [ `Strict_type of strict_type | `Atype of atype ] list (* zero or more *)
)

type decl_type (* inlined *) = (
    Token.t (* "type" *)
  * tyfam_head
  * [
        `EQ_type_or_impl of (Token.t (* "=" *) * type_or_implicit)
      | `Type_anno of type_annotation
    ]
)

type class_datafam (* inlined *) = (
    Token.t (* "data" *)
  * Token.t (* "family" *) option
  * tyfam_head
  * type_annotation option
)

type class_tyfam (* inlined *) = (
    Token.t (* "type" *)
  * Token.t (* "family" *) option
  * tyfam_head
  * type_annotation option
)

type decl_datafam (* inlined *) = (
    Token.t (* "data" *)
  * Token.t (* "family" *)
  * tyfam_head
  * type_annotation option
)

type decl_deriving (* inlined *) = (
    Token.t (* "deriving" *)
  * [ `Deri_stra of deriving_strategy | `Via of via ] option
  * instance
)

type gadt_fun (* inlined *) = (
    anon_choice_strict_type_5770e7f * arrow * gadt_sig
)

type data_constructor_infix (* inlined *) = (
    anon_choice_strict_type_5770e7f * conop * anon_choice_strict_type_5770e7f
)

type decl_pattern (* inlined *) = (
    Token.t (* "pattern" *)
  * [
        `Pat_type of pattern_type
      | `Pat_equals of pattern_equals
      | `Pat_arrow of pattern_arrow
    ]
)

type data_constructor_record (* inlined *) = (tyconid * record_fields)

type decl_tyfam (* inlined *) = (
    Token.t (* "type" *)
  * Token.t (* "family" *)
  * tyfam_head
  * [ `Type_anno of type_annotation | `Tyfam_inj of tyfam_inj ] option
  * (
        where (*tok*)
      * [
            `LCURL_opt_tyfam_eq_rep_SEMI_tyfam_eq_opt_SEMI_RCURL of (
                Token.t (* "{" *)
              * (
                    tyfam_eq
                  * (Token.t (* ";" *) * tyfam_eq) list (* zero or more *)
                )
                  option
              * Token.t (* ";" *) option
              * Token.t (* "}" *)
            )
          | `Layout_start_opt_tyfam_eq_rep_choice_SEMI_tyfam_eq_opt_choice_SEMI_layout_end of (
                layout_start (*tok*)
              * (
                    tyfam_eq
                  * (anon_choice_SEMI_ab17175 * tyfam_eq)
                      list (* zero or more *)
                  * anon_choice_SEMI_ab17175 option
                )
                  option
              * layout_end (*tok*)
            )
        ]
          option
    )
      option
)

type gadt_constructor (* inlined *) = (con * gadt_constr_type)

type decl_class (* inlined *) = (
    Token.t (* "class" *)
  * context_ option
  * constraint_
  * fundeps option
  * class_body option
)

type decl_newtype (* inlined *) = (
    Token.t (* "newtype" *)
  * context_newtype
  * [
        `Newt of newtype
      | `Opt_type_anno_gadt_rhs of (type_annotation option * gadt_rhs)
    ]
)

type decl_adt (* inlined *) = (
    Token.t (* "data" *)
  * context_ option
  * tyfam_head
  * type_annotation option
  * [ `Adt of adt | `Rep_deri of deriving list (* zero or more *) ] option
)

type decl_instance (* inlined *) = (
    instance
  * (
        where (*tok*)
      * [
            `LCURL_opt_idecl_rep_SEMI_idecl_opt_SEMI_RCURL of (
                Token.t (* "{" *)
              * (idecl * (Token.t (* ";" *) * idecl) list (* zero or more *))
                  option
              * Token.t (* ";" *) option
              * Token.t (* "}" *)
            )
          | `Layout_start_opt_idecl_rep_choice_SEMI_idecl_opt_choice_SEMI_layout_end of (
                layout_start (*tok*)
              * (
                    idecl
                  * (anon_choice_SEMI_ab17175 * idecl)
                      list (* zero or more *)
                  * anon_choice_SEMI_ab17175 option
                )
                  option
              * layout_end (*tok*)
            )
        ]
          option
    )
      option
)

type module_ (* inlined *) = (
    Token.t (* "module" *)
  * qmodid
  * exports option
  * where (*tok*)
  * [
        `LCURL_opt_topd_rep_SEMI_topd_opt_SEMI_RCURL of (
            Token.t (* "{" *)
          * (topdecl * (Token.t (* ";" *) * topdecl) list (* zero or more *))
              option
          * Token.t (* ";" *) option
          * Token.t (* "}" *)
        )
      | `Layout_start_opt_topd_rep_choice_SEMI_topd_opt_choice_SEMI_layout_end of (
            layout_start (*tok*)
          * anon_topd_rep_choice_SEMI_topd_opt_choice_SEMI_eb02f02 option
          * layout_end (*tok*)
        )
    ]
      option
)

type extra = 
    Cpp of Loc.t * cpp
  | Comment of Loc.t * comment
  | Pragma of Loc.t * pragma


type extras = extra list
